%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{QSOFT Documentation}
\date{Dec 05, 2018}
\release{9.0}
\author{Richard Willingale}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


QSOFT is a collection of data analysis and modelling applications for use in X-ray astronomy and related disciplines.

The applications are run as commands/functions within Python, R or IDL.

The core code is written in Fortran and C, compiled to produce shareable object libraries and imported as modules in Python or loaded by R or IDL.

The commands/functions are defined in Python modules, R or IDL scripts.

The QSOFT collection should be built using the gcc and gfortran compilers. The Python module f2py and/or R must be available to create the shareable objects.


\chapter{Build and Installation}
\label{\detokenize{installation:build-and-installation}}\label{\detokenize{installation::doc}}
The following software items are required for the build:
\begin{itemize}
\item {} 
Fortran compiler - GNU gfortran used in development

\item {} 
C compiler - GNU gcc used in development

\item {} 
Python module f2py - to build the modules for Python

\item {} 
R - to build the shareable libraries for R and IDL

\item {} 
Python module sphinx - to build the documentation

\end{itemize}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Download from GitHub
\begin{quote}

\$ git clone git://github.com/dickwillingale/qsoft.git

This will create a directory qsoft/
\end{quote}

\end{enumerate}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi )}
\makeatletter\def\p@enumii{\p@enumi \theenumi )}\makeatother
\setcounter{enumi}{1}
\item {} 
Move into /your/files/top/qsoft/src
\begin{quote}

\$ cd /your/files/top/qsoft/src

Edit the compile.config so that the compilers CC and F77 and R, F2PY and IDL
point to the correct executables on your system.
If you don’t have R or F2PY leave them blank. If your target is IDL you will
need R to compile the shareable library.
\end{quote}

\end{enumerate}
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{2}
\item {} 
Move into /your/files/top/qsoft and execute build
\begin{quote}

\$ cd /your/files/top/qsoft

\$ ./build

This will check you have gcc gfortran and R and/or Python with f2py.  It will then create the src/compiler.config file for make and compile the shareable objects.
\end{quote}

\item {} 
Put the following line into your /home/.profile
\begin{quote}

. /your/files/top/qsoft/setup\_q

Qsoft will be available when you launch a login terminal.
\end{quote}

\item {} 
That’s it.
\begin{quote}

When you start R (or Rscript) it will automatically load the QSOFT applications
using the /home/.Rprofile file.

The environment variable PYTHONPATH will point to the qsoft/python\_modules
directory so you can load the modules into Python.
\end{quote}

\end{enumerate}


\chapter{Python, R and IDL}
\label{\detokenize{using_py_R_IDL:python-r-and-idl}}\label{\detokenize{using_py_R_IDL::doc}}
All the Fortran functions can be called from Python, R or IDL.
Because of peculiarities in the syntax and structure of the scripting languages
there are minor differences in the way the functions are accessed.

The documentation of all the functions uses the Python implementation. Where
there are significant differences in the R or IDL versions these are
mentioned in the text.


\section{Python}
\label{\detokenize{using_py_R_IDL:python}}
The directory \$QSOFT/python\_modules is included in the PYTHONPATH at set up so
that the python  modules can be imported in the usual way. Here is a
snippet of a Python script using the astro.cosmo() function

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{c+c1}{\PYGZsh{} Test of Cosmological parameter calculations etc.}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{astro}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{zmax}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{c+c1}{\PYGZsh{} Einstein de Sitter}
\PYG{n}{c1}\PYG{o}{=}\PYG{n}{astro}\PYG{o}{.}\PYG{n}{cosmo}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Low density}
\PYG{n}{c2}\PYG{o}{=}\PYG{n}{astro}\PYG{o}{.}\PYG{n}{cosmo}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{,}\PYG{l+m+mf}{0.05}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} High Lambda}
\PYG{n}{c3}\PYG{o}{=}\PYG{n}{astro}\PYG{o}{.}\PYG{n}{cosmo}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{,}\PYG{l+m+mf}{0.2}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{,}\PYG{n}{zmax}\PYG{p}{)}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\end{sphinxVerbatim}


\section{RScript}
\label{\detokenize{using_py_R_IDL:rscript}}
The file .Rprofile in the users home directory is executed by Rscript at start
up to dynamically load the shareable libraries. The QSOFT R function names
are prefixed according to the module library/subject as follows
\begin{itemize}
\item {} 
utilities: qr\_

\item {} 
qfits: qr\_fits

\item {} 
images: qri\_

\item {} 
astro: qra\_

\item {} 
xscat: qrx\_

\item {} 
xsrt: qrt\_

\end{itemize}

Here is a snippet of a Rscript using the astro.cosmo() function

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}!/usr/bin/env Rscript}
\PYG{c+c1}{\PYGZsh{} Test of Cosmological parameter distance calculations}
    zmax\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{l+m}{5}
\PYG{c+c1}{\PYGZsh{} Einstein de Sitter}
    c1\PYG{o}{\PYGZlt{}\PYGZhy{}}qra\PYGZus{}cosmo\PYG{p}{(}\PYG{l+m}{70}\PYG{p}{,}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}zmax\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Low density}
    c2\PYG{o}{\PYGZlt{}\PYGZhy{}}qra\PYGZus{}cosmo\PYG{p}{(}\PYG{l+m}{70}\PYG{p}{,}\PYG{l+m}{0.05}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}zmax\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} High Lambda}
    c3\PYG{o}{\PYGZlt{}\PYGZhy{}}qra\PYGZus{}cosmo\PYG{p}{(}\PYG{l+m}{70}\PYG{p}{,}\PYG{l+m}{0.2}\PYG{p}{,}\PYG{l+m}{0.8}\PYG{p}{,}zmax\PYG{p}{)}
\PYG{k+kc}{...}
\end{sphinxVerbatim}


\section{IDL}
\label{\detokenize{using_py_R_IDL:idl}}

\chapter{qfits - Using FITS Files}
\label{\detokenize{qfits:qfits-using-fits-files}}\label{\detokenize{qfits::doc}}
The qfits interface has not yet been implemented in IDL.

Reading and writing of FITS files is available in Python and R.


\section{Reading FITS Files}
\label{\detokenize{qfits_read:reading-fits-files}}\label{\detokenize{qfits_read::doc}}
The entire contents of a FITS file can be read into a Python or R object
using a single call as illustrated below.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{k+kn}{import} \PYG{n+nn}{qfits}
\PYG{n}{filename}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}fitsnew.fits}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{fitsin}\PYG{o}{=}\PYG{n}{qfits}\PYG{o}{.}\PYG{n}{fitsfile}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Print summary}
\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Access the number of HDUs in FITS file}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{number of hdu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{nhdu}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} The primary array}
\PYG{k}{print}\PYG{p}{(}\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{hdu}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{data\PYGZus{}array}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} All the keywords on extension 1}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HDU 1 keywords}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{hdu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} A Particular keyword on extension 1}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HDU 1 keyword NAXIS1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{hdu}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NAXIS1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} The complete table on extension 2}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HDU 2 table}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{hdu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{table}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} A particular column from table on extension 2}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{HDU 2 table column s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{fitsin}\PYG{o}{.}\PYG{n}{hdu}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}!/usr/bin/env Rscript}
filename\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test\PYGZus{}fitsnew.fits\PYGZdq{}}
fitsin\PYG{o}{\PYGZlt{}\PYGZhy{}} qr\PYGZus{}fitsread\PYG{p}{(}filename\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Print a summary}
qr\PYGZus{}fitsprint\PYG{p}{(}fitsin\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Get the number of HDU (primary + extensions)}
\PYG{k+kp}{cat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{number of HDU\PYGZdq{}}\PYG{p}{,}fitsin\PYG{o}{\PYGZdl{}}NHDU\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZbs{}n\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Print the primary data arra}
\PYG{k+kp}{print}\PYG{p}{(}fitsin\PYG{o}{\PYGZdl{}}primary\PYG{o}{\PYGZdl{}}DATA\PYGZus{}ARRAY\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Access a particular keyword in extension 2}
\PYG{k+kp}{cat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{HDU extension 2 keyword TESTD\PYGZdq{}}\PYG{p}{,}fitsin\PYG{o}{\PYGZdl{}}extension\PYG{p}{[[}\PYG{l+m}{2}\PYG{p}{]]}\PYG{o}{\PYGZdl{}}TESTD\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZbs{}n\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} All the keywords on extension 2}
\PYG{k+kp}{print}\PYG{p}{(}fitsin\PYG{o}{\PYGZdl{}}extension\PYG{p}{[[}\PYG{l+m}{2}\PYG{p}{]]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} The complete table on extension 2}
\PYG{k+kp}{print}\PYG{p}{(}fitsin\PYG{o}{\PYGZdl{}}extension\PYG{p}{[[}\PYG{l+m}{2}\PYG{p}{]]}\PYG{o}{\PYGZdl{}}\PYG{k+kp}{table}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} A particular column from table on extension 2}
\PYG{k+kp}{print}\PYG{p}{(}fitsin\PYG{o}{\PYGZdl{}}extension\PYG{p}{[[}\PYG{l+m}{2}\PYG{p}{]]}\PYG{o}{\PYGZdl{}}\PYG{k+kp}{table}\PYG{p}{[}\PYG{p}{,}\PYG{l+m}{3}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

Because the indexing of lists and arrays starts at zero in Python and 1 in R
the internal structure of the object returned is different.

In Python the primary HDU is hdu{[}0{]} and extensions are hdu{[}1{]}, hdu{[}2{]} etc..

In R the primary is called primary and the extensions are a list
accessed as extension{[}{[}1{]}{]}, extension{[}{[}2{]}{]} etc..

In Python the keywords are stored in a dictionary and
particular keywords are accessed using a name index.

In R the
keywords are stored as named variables within the extension list.

The summary listings produced by fitsfile.display() in Python and
qr\_fitsprint() in R can be used to reveal the way in which the contents of
the FITS file are stored in memory.

Details on how to access all the elements of FITS files can be found in the
source for the Python class fitsfile and R function qr\_fitsread() which are
defined in \$QSOFT/src/qfits/qfits.py and \$QSOFT/src/qfits/qfits.R.


\section{Writing FITS Files}
\label{\detokenize{qfits_write:writing-fits-files}}\label{\detokenize{qfits_write::doc}}
FITS files can be created using a Python or R script as
illustrated below. Python uses methods in class fitsfile and
class fitshdu. R uses functions qr\_fits*().

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{qfits}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{a}\PYG{o}{=}\PYG{n}{qfits}\PYG{o}{.}\PYG{n}{fitsfile}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{new}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Primary array}
\PYG{n}{hdu}\PYG{o}{=}\PYG{n}{qfits}\PYG{o}{.}\PYG{n}{fitshdu}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{arr}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mf}{101.1}
\PYG{n}{arr}\PYG{o}{.}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{data\PYGZus{}array}\PYG{o}{=}\PYG{n}{arr}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hdu}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Extension Arrays}
\PYG{n}{hdu}\PYG{o}{=}\PYG{n}{qfits}\PYG{o}{.}\PYG{n}{fitshdu}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{iarr}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}
\PYG{n}{iarr}\PYG{o}{=}\PYG{n}{iarr}\PYG{p}{[}\PYG{p}{:}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{iarr}\PYG{o}{.}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{]}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{data\PYGZus{}array}\PYG{o}{=}\PYG{n}{iarr}
\PYG{c+c1}{\PYGZsh{} Add some comments}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{cr}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is a test comment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{cr}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{This is some history}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} keywords}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mf}{55.5}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kc}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTD}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a test double value}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTJ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{28}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kc}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTJ}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a test integer value}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb+bp}{True}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kc}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTL}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a true logical value}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n+nb+bp}{False}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kc}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a false logical value}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kw}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a string}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{kc}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TESTS}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{a test string value}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hdu}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Tables}
\PYG{n}{hdu}\PYG{o}{=}\PYG{n}{qfits}\PYG{o}{.}\PYG{n}{fitshdu}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{ix}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{ix}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{o}{+}\PYG{n}{ix}\PYG{o}{*}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{float}\PYG{p}{)}
\PYG{n}{ix}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{ix}\PYG{o}{*}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{)}
\PYG{n}{y}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{aaaaaaaaaaa}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bbbbbbbbbbb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ccccccccccc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ddddddddddd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{z}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{,}\PYG{n+nb+bp}{False}\PYG{p}{,}\PYG{n+nb+bp}{True}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{q}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{int8}\PYG{p}{)}
\PYG{n}{s}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{55}\PYG{o}{+}\PYG{l+m+mi}{22j}\PYG{p}{,}\PYG{l+m+mi}{66}\PYG{o}{+}\PYG{l+m+mi}{23j}\PYG{p}{,}\PYG{l+m+mi}{77}\PYG{o}{+}\PYG{l+m+mi}{24j}\PYG{p}{,}\PYG{l+m+mi}{88}\PYG{o}{+}\PYG{l+m+mi}{25j}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{xx}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n+nb}{float}\PYG{p}{)}
\PYG{n}{xx}\PYG{o}{.}\PYG{n}{shape}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}
\PYG{n}{b\PYGZus{}bits}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1000000111}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0111001101}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0010000010}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0001101100}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{rnames}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\PYG{n}{short}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.1}\PYG{p}{,}\PYG{l+m+mf}{2.2}\PYG{p}{,}\PYG{l+m+mf}{3.3}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{ix}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{units}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ix}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{splogs}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{x}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{x}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{xx}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{xx}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{y}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{y}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{z}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{z}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{q}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{q}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{s}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{s}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{b\PYGZus{}bits}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{b\PYGZus{}bits}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{short}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{short}
\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{table}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rnames}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{rnames}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{hdu}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hdu}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{nhdu}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{c+c1}{\PYGZsh{} Print a summary and save}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{display}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{a}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{test\PYGZus{}fitsnew.fits}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}!/usr/bin/env Rscript}
qr\PYGZus{}fitsnew\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fitswrite\PYGZus{}test.fits\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Primary array}
arr\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kp}{seq}\PYG{p}{(}from\PYG{o}{=}\PYG{l+m}{10.1}\PYG{p}{,}to\PYG{o}{=}\PYG{l+m}{20}\PYG{p}{,}length.out\PYG{o}{=}\PYG{l+m}{100}\PYG{p}{)}
\PYG{k+kp}{dim}\PYG{p}{(}arr\PYG{p}{)}\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{,}\PYG{l+m}{20}\PYG{p}{)}
qr\PYGZus{}fitsparrd\PYG{p}{(}arr\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Extension Arrays}
iarr\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{l+m}{100}\PYG{o}{:}\PYG{l+m}{1}
\PYG{k+kp}{dim}\PYG{p}{(}iarr\PYG{p}{)}\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{5}\PYG{p}{,}\PYG{l+m}{20}\PYG{p}{)}
qr\PYGZus{}fitsparrj\PYG{p}{(}iarr\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Comments and history cards}
qr\PYGZus{}fitspcom\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is a test comment\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitsphis\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{This is some history\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitsempty\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} keywords}
qr\PYGZus{}fitspkeyd\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TESTD\PYGZdq{}}\PYG{p}{,}\PYG{l+m}{55.5}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a test double value\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitspkeyj\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TESTJ\PYGZdq{}}\PYG{p}{,}\PYG{l+m}{28}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a test integer value\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitspkeyl\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TESTL\PYGZdq{}}\PYG{p}{,}\PYG{n+nb+bp}{T}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a true logical value\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitspkeyl\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TESTF\PYGZdq{}}\PYG{p}{,}\PYG{n+nb+bp}{F}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a false logical value\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitspkeys\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{TESTS\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a string\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a test string value\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Tables}
x\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{10.10}\PYG{p}{,}\PYG{l+m}{20.20}\PYG{p}{,}\PYG{l+m}{30.30}\PYG{p}{,}\PYG{l+m}{40.40}\PYG{p}{)}
ix\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kp}{as.integer}\PYG{p}{(}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{10}\PYG{p}{,}\PYG{l+m}{20}\PYG{p}{,}\PYG{l+m}{30}\PYG{p}{,}\PYG{l+m}{40}\PYG{p}{)}\PYG{p}{)}
y\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aaaaaaaaaaa\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bbbbbbbbbbb\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ccccccccccc\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ddddddddddd\PYGZdq{}}\PYG{p}{)}
z\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{n+nb+bp}{T}\PYG{p}{,}\PYG{n+nb+bp}{T}\PYG{p}{,}\PYG{n+nb+bp}{F}\PYG{p}{,}\PYG{n+nb+bp}{T}\PYG{p}{)}
\PYG{k+kp}{q}\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kp}{as.raw}\PYG{p}{(}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{9}\PYG{p}{,}\PYG{l+m}{8}\PYG{p}{,}\PYG{l+m}{7}\PYG{p}{,}\PYG{l+m}{6}\PYG{p}{)}\PYG{p}{)}
s\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{complex}\PYG{p}{(}real\PYG{o}{=}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{55}\PYG{p}{,}\PYG{l+m}{66}\PYG{p}{,}\PYG{l+m}{77}\PYG{p}{,}\PYG{l+m}{88}\PYG{p}{)}\PYG{p}{,}imaginary\PYG{o}{=}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{22}\PYG{p}{,}\PYG{l+m}{23}\PYG{p}{,}\PYG{l+m}{24}\PYG{p}{,}\PYG{l+m}{25}\PYG{p}{)}\PYG{p}{)}
rnames\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r1\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r2\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r3\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{r4\PYGZdq{}}\PYG{p}{)}
tt\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{data.frame}\PYG{p}{(}x\PYG{p}{,}ix\PYG{p}{,}y\PYG{p}{,}z\PYG{p}{,}\PYG{k+kp}{q}\PYG{p}{,}s\PYG{p}{,}stringsAsFactors\PYG{o}{=}\PYG{n+nb+bp}{F}\PYG{p}{,}row.names\PYG{o}{=}rnames\PYG{p}{)}
qr\PYGZus{}fitspobj\PYG{p}{(}tt\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dframe\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitsclose\PYG{p}{(}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Print a summary}
fitsin\PYG{o}{\PYGZlt{}\PYGZhy{}} qr\PYGZus{}fitsread\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{fitswrite\PYGZus{}test.fits\PYGZdq{}}\PYG{p}{)}
qr\PYGZus{}fitsprint\PYG{p}{(}fitsin\PYG{p}{)}
\end{sphinxVerbatim}


\section{qfits.functions}
\label{\detokenize{qfits_functions:module-qfits}}\label{\detokenize{qfits_functions:qfits-functions}}\label{\detokenize{qfits_functions::doc}}\index{qfits (module)}\index{fitscolnam() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitscolnam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitscolnam}}}{\emph{ic}, \emph{rr}, \emph{nrows}}{}
Get FITS table column name - internal routine
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ic}} \textendash{} column index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rr}} \textendash{} 0 if variable column width

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nrows}} \textendash{} number of rows

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{colnam}    column name
\item[] \sphinxstylestrong{iname}     number of characters in colnam
\item[] \sphinxstylestrong{vrep}      variable repeat count
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{fitsgcol() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsgcol}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsgcol}}}{\emph{ic}, \emph{typ}, \emph{nrows}, \emph{rp}, \emph{vr}}{}
Get column from table on FITS file - internal function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ic}} \textendash{} column number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{typ}} \textendash{} column data type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nrows}} \textendash{} number of column rows

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rp}} \textendash{} repeat count

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vr}} \textendash{} If rp zero then vr{[}nrows{]} is variable count for each row

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{The following variables are used internally:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] nc: the number of calls required to get complete column
\item[] ne: length returned per call
\item[] qt: 1 complete column returned in 1 call
\item[] qt: 2 1 call per row fixed width returned as a list
\item[] qt: 3 variable width column 1 call per row returned as a list
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{fitsgcolv() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsgcolv}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsgcolv}}}{\emph{typ}, \emph{ic}, \emph{ii}, \emph{ne}}{}
Get columm values from FITS file - internal function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{typ}} \textendash{} column data type returned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ic}} \textendash{} column number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ii}} \textendash{} first row number

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ne}} \textendash{} number of elements

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{\sphinxstylestrong{typ} values:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] 0   none
\item[] 1   integer
\item[] 2   double
\item[] 3   logical
\item[] 4   bit as string 1 or 0
\item[] 5   real complex
\item[] 6   double complex
\item[] 7   byte integer 8
\item[] 8   bit row as a character string
\end{DUlineblock}

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
values from column

\end{description}\end{quote}

\end{fulllineitems}

\index{fitsgetkey() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsgetkey}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsgetkey}}}{\emph{ikey}}{}
Get FITS keyword - internal function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ikey}} \textendash{} keyword index

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{key}    keyword string
\item[] \sphinxstylestrong{ki}     number of characters in keyword string
\item[] \sphinxstylestrong{sval}   string value
\item[] \sphinxstylestrong{si}     number of characters in string value
\item[] \sphinxstylestrong{jval}   integer value
\item[] \sphinxstylestrong{dval}   double value
\item[] \sphinxstylestrong{lval}   logical value
\item[] \sphinxstylestrong{ktype}  type of value returned
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1 integer in jval
\item[] 2 real in dval
\item[] 3 logical in jval
\item[] 4 string in sval
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{fitshduinfo() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitshduinfo}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitshduinfo}}}{\emph{ihdu}}{}
Get FITS header dimension info - internal function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ihdu}} \textendash{} HDU index

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{hdutype}    type of HDU
\item[] \sphinxstylestrong{naxis}      number of dimensions
\item[] \sphinxstylestrong{naxes}      size of dimensions (nrows,ncols)
\item[] \sphinxstylestrong{nkeys}      number of keywords
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{fitsparr() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsparr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsparr}}}{\emph{arr}}{}
Put array onto fits file - internal function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{arr}} \textendash{} arr of data values

\end{description}\end{quote}

\end{fulllineitems}

\index{fitsptab() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsptab}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsptab}}}{\emph{hdu}}{}
Create binary table HDU on FITS object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{hdu}} \textendash{} FITS HDU object

\end{description}\end{quote}

\end{fulllineitems}

\index{fitstypes() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitstypes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitstypes}}}{\emph{hdutype}, \emph{ncols}}{}
Get FITS header data types - internal function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hdutype}} \textendash{} type of HDU

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ncols}} \textendash{} number of columns (if hdutype=0)

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{ctype}   column type
\item[] \sphinxstylestrong{rp}      column repeat count
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{fitsupdate() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsupdate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsupdate}}}{\emph{filename}}{}
Open FITS file for read/write
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} FITS file name

\item[{Returns}] \leavevmode
number of HDU in file

\end{description}\end{quote}

\end{fulllineitems}

\index{init() (in module qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.init}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{init}}}{}{}
Initialize common blocks on import

\end{fulllineitems}

\index{fitsfile (class in qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsfile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitsfile}}}{\emph{filename}}{}~\index{\_\_init\_\_() (qfits.fitsfile method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsfile.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{filename}}{}
Read object from FITS file or create new FITS object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} FITS filename (“new” to create new object)

\end{description}\end{quote}

\end{fulllineitems}

\index{display() (qfits.fitsfile method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsfile.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
List FITS object

\end{fulllineitems}

\index{save() (qfits.fitsfile method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitsfile.save}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save}}}{\emph{filename}}{}
Save FITS object to file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} FITS file name

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{fitshdu (class in qfits)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitshdu}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{qfits.}}\sphinxbfcode{\sphinxupquote{fitshdu}}}{\emph{ihdu}, \emph{hdutype}}{}~\index{\_\_init\_\_() (qfits.fitshdu method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitshdu.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{ihdu}, \emph{hdutype}}{}
FITS HDU object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ihdu}} \textendash{} HDU index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hdutype}} \textendash{} HDU type

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{display() (qfits.fitshdu method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qfits_functions:qfits.fitshdu.display}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{display}}}{}{}
List FITS HDU object

\end{fulllineitems}


\end{fulllineitems}



\chapter{images  - Image Processing}
\label{\detokenize{images:images-image-processing}}\label{\detokenize{images::doc}}
Positions in images. The coordinates of an image field are set up
using the function setfield(). The \sphinxstyleemphasis{current position} can be set using the
function setpos(). This position is then used by functions like beam().
The position is
given in pixel coordinates (a real scale running 0-NCOLS in X and 0-NROWS in Y)
and local X,Y (usually taken as mm). If, in addition to setfield(),
sky coordinates are set using the function setsky() the \sphinxstyleemphasis{current position} is
also specified in local
azimuth and elevation (degrees), Celestial RA,DEC (degrees J2000), Ecliptic
EA,EL (degrees) and Galactic LII, BII (degrees). The sky coordinates can be
set using different projections, Plate Carre, Aitoff (Hammer) or Lambert
(equatorial aspect of Azimuthal equal-area).
\begin{itemize}
\item {} 
setfield() Set local coordinates for image field

\item {} 
setsky() Set up sky coordinates for image field

\item {} 
setpos() Set current position in image field

\item {} 
getpos() Get current position in image field

\item {} 
toxy() Convert position to local xy coordinates

\item {} 
plt\_show\_locator() Get local coordinate positions using the cursor

\end{itemize}

Analysis of a beam containing a source or PSF. The beam is centred at the
\sphinxstyleemphasis{current positon} (see above).
\begin{itemize}
\item {} 
beam() Analysis of source above background within a circular beam

\item {} 
sqbeam() Analysis of source above background within a square beam

\item {} 
lecbeam() Analysis of source above background in a lobster eye cross-beam

\end{itemize}

Creation of images from event lists or 2-d functions.
In Python these function return a 2-d array. In R they return
an image object which contains the array and ancillary information.
\begin{itemize}
\item {} 
binxy() x-y event binning to form an image array

\item {} 
lebin() Create an image from an event list binning using lobster eye psf

\item {} 
lecimage() Create an image array of the lobster eye cross-beam

\item {} 
lepsf() Create an image of the lobster eye PSF

\end{itemize}

Drawing over images. The function hamgrid() and lamgrid() will only work if
sky coordinates have been set up using setsky().
\begin{itemize}
\item {} 
rectangles() Draw rectangles

\item {} 
hamgrid() Plot a Hammer projection grid on figure

\item {} 
lamgrid() Plot a Lambert projection grid on figure

\end{itemize}

1-d profiles
\begin{itemize}
\item {} 
gaussian() Gaussian profile

\item {} 
king\_profile() King function (modified Lorentzian) profile

\item {} 
lorentzian() Lorentzian profile

\end{itemize}

Model function fitting using a statistic. Can be used for fitting of PSF profiles to image data or more generally for fitting data with a model function.
\begin{itemize}
\item {} 
srchmin() Search for minimum statistic and return best fit parameters and confidence limits of the parameters

\item {} 
peakchisq() Chi-squared for image peak fitting

\item {} 
quaderr() Quadratic estimator for confidence limit

\end{itemize}


\section{images.functions}
\label{\detokenize{images_functions:module-images}}\label{\detokenize{images_functions:images-functions}}\label{\detokenize{images_functions::doc}}\index{images (module)}\index{beam() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.beam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{beam}}}{\emph{arr}, \emph{rbeam}, \emph{blev}, \emph{bvar}}{}
Analysis of source above background within a circular beam
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{arr}} \textendash{} image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rbeam}} \textendash{} radius of beam in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blev}} \textendash{} average background level per pixel (to be subtracted)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bvar}} \textendash{} variance on blev (-ve for counting statistics)

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list with the following
\item[] \sphinxstylestrong{nsam}:    number of pixels in beam
\item[] \sphinxstylestrong{bflux}:   background in beam (e.g. counts)
\item[] \sphinxstylestrong{bsigma}:  standard deviation of background
\item[] \sphinxstylestrong{flux}:    source flux above background in beam (e.g. counts)
\item[] \sphinxstylestrong{fsigma}:  standard deviation of source flux
\item[] \sphinxstylestrong{peak}:    source x,y peak position
\item[] \sphinxstylestrong{cen}:     source x,y centroid position
\item[] \sphinxstylestrong{tha}:     angle (degrees) of major axis wrt x (x to y +ve)
\item[] \sphinxstylestrong{rmsa}:    source max rms width (major axis) (pixels)
\item[] \sphinxstylestrong{rmsb}:    source min rms width (minor axis) (pixels)
\item[] \sphinxstylestrong{fwhm}:    full width half maximum (pixels) about beam centre
\item[] \sphinxstylestrong{hew}:     half energy width (pixels) about beam centre
\item[] \sphinxstylestrong{w90}:     W90 (90\% width) (pixels) about beam centre
\item[] \sphinxstylestrong{fwhmp}:   full width half maximum (pixels) about peak
\item[] \sphinxstylestrong{hewp}:    half energy width (pixels) about peak
\item[] \sphinxstylestrong{w90p}:    W90 (90\% width) (pixels) about peak
\item[] \sphinxstylestrong{fwhmc}:   full width half maximum (pixels) about centroid
\item[] \sphinxstylestrong{hewc}:    half energy width (pixels) about centroid
\item[] \sphinxstylestrong{w90c}:    W90 (90\% width) (pixels) about centroid
\item[] \sphinxstylestrong{fit}:     parameters from peak fit using peakchisq()
\end{DUlineblock}


\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] 
\item[] Fit performed if bvar!=0.
\item[] Parameters are saved in the list fit (see function srchmin())
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 0:      peak value (no error range calculated)
\item[] 1:      peak X pixel position with 90\% error range
\item[] 2:      peak Y pixel position with 90\% error range
\item[] 3:      Lorentzian width including 90\% upper and lower bounds
\item[] 
\end{DUlineblock}
\item[] The position of the beam is the current position within the image.
\item[] Use function setpos() to set the current position.
\end{DUlineblock}

\end{fulllineitems}

\index{binxy() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.binxy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{binxy}}}{\emph{x}, \emph{y}, \emph{iq}, \emph{w}, \emph{xleft}, \emph{xright}, \emph{ybot}, \emph{ytop}, \emph{nx}, \emph{ny}}{}
x-y event binning to form an image
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} array of x positions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Y}} \textendash{} array of y positions

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} array of quality values (0 for OK)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} array of weights

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xleft}} \textendash{} minimum x value (left edge) for image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xright}} \textendash{} maximum x value (rigth edge) for image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ybot}} \textendash{} minimum y value (bottom edge) for image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ytop}} \textendash{} maximum y value (top edge) for image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nx}} \textendash{} size of 1st dimension of image array (number of rows)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ny}} \textendash{} size of 2nd dimension of image array (number of columns)

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] image array
\item[] R version returns an image object - image array object\$data\_array
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{gaussian() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.gaussian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{gaussian}}}{\emph{x}, \emph{p}}{}
Gaussian profile
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} array of x values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} array of fitting parameters

\end{itemize}

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] par 0: normalisation (value at peak)
\item[] par 1: x-centre (pixel position)
\item[] par 2: Gaussian full width half maximum (pixels)
\end{DUlineblock}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
array of function values evaluated at x

\end{description}\end{quote}

\end{fulllineitems}

\index{getpos() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.getpos}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{getpos}}}{}{}
Get current position in image field
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list with following

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{pix}:     pixel position
\item[] \sphinxstylestrong{xyl}:     local position
\item[] \sphinxstylestrong{aes}:     local azimuth,elevation degrees
\item[] \sphinxstylestrong{equ}:     Celestial RA,DEC degrees J2000
\item[] \sphinxstylestrong{ecl}:     Ecliptic EA,EL degrees
\item[] \sphinxstylestrong{gal}:     Galactic LII,BII degrees
\end{DUlineblock}

\end{fulllineitems}

\index{hamgrid() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.hamgrid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{hamgrid}}}{\emph{pic}}{}
Plot a Hammer projection grid on figure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{pic}} \textendash{} figure object

\end{description}\end{quote}

\end{fulllineitems}

\index{init() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.init}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{init}}}{}{}
Initialise common blocks on import

\end{fulllineitems}

\index{king\_profile() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.king_profile}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{king\_profile}}}{\emph{x}, \emph{p}}{}
King function (modified Lorentzian) profile
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} array of x values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} array of fitting parameters

\end{itemize}

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] par 0: normalisation (value at peak)
\item[] par 1: x-centre (pixel position)
\item[] par 2: full width half maximum (pixels)
\item[] par 3: power index (1 for Lorentzian)
\end{DUlineblock}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
array of function values evaluated at x

\end{description}\end{quote}

\end{fulllineitems}

\index{lamgrid() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.lamgrid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{lamgrid}}}{\emph{pic}}{}
Plot a Lambert projection grid on figure
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{pic}} \textendash{} figure object

\end{description}\end{quote}

\end{fulllineitems}

\index{lebin() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.lebin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{lebin}}}{\emph{xe}, \emph{ye}, \emph{s}, \emph{h}, \emph{g}, \emph{eta}, \emph{nx}, \emph{ny}}{}
Create an image from an event list binning using lobster eye psf

The image is effectively a cross-correlation of the event list with the lobster eye cross-beam.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xe}} \textendash{} x event positions, pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ye}} \textendash{} y event positions, pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} size of cross-beam square area in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} height of cross-arm triangle in pixels (=2d/L)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{g}} \textendash{} width of Lorentzian central spot in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eta}} \textendash{} cross-arm to peak ratio at centre

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nx}} \textendash{} first dimension of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ny}} \textendash{} second dimension of array

\end{itemize}

\item[{Returns}] \leavevmode
image array

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] Event positions assumed to run:
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] x: 0 left edge to nx right edge
\item[] y: 0 bottom edge to ny top edge
\end{DUlineblock}
\item[] Therefore centre of left bottom pixel is 0.5,0.5
\end{DUlineblock}

\end{fulllineitems}

\index{lecbeam() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.lecbeam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{lecbeam}}}{\emph{arr}, \emph{s}, \emph{h}, \emph{blev}, \emph{bvar}, \emph{nt}}{}
Analysis of source above background in a lobster eye cross-beam
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{arr}} \textendash{} image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} size of cross-beam square area in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} height of cross-arm quadrant in pixels (=2d/L)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blev}} \textendash{} average background level per pixel (to be subtracted)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bvar}} \textendash{} variance on blev (-ve for counting statistics)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nt}} \textendash{} dimension of output quadrant flux distribution in pixels

\end{itemize}

\item[{Returns}] \leavevmode
list of the following

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{qua}:     quadrant surface brightness distribution array nt by nt
\item[] \sphinxstylestrong{quan}:    quadrant  pixel occupancy array nt by nt
\item[] \sphinxstylestrong{nsam}:    number of pixels in beam
\item[] \sphinxstylestrong{bflux}:   background in beam (e.g. counts)
\item[] \sphinxstylestrong{bsigma}:  standard deviation of background
\item[] \sphinxstylestrong{flux}:    source flux above background in beam (e.g. counts)
\item[] \sphinxstylestrong{fsigma}:  standard deviation of source flux
\item[] \sphinxstylestrong{peak}:    source x,y peak position
\item[] \sphinxstylestrong{cen}:     source x,y centroid position
\item[] \sphinxstylestrong{hew}:     half energy width (pixels)
\item[] \sphinxstylestrong{w90}:     W90 (90\% width) (pixels)
\item[] \sphinxstylestrong{ahe}:     half energy area (sq pixels)
\item[] \sphinxstylestrong{aw9}:     W90 (90\% width) area (sq pixels)
\item[] \sphinxstylestrong{fpeak}:   flux in peak pixel
\item[] 
\item[] The position of the beam is the current position within the image.
\item[] Use function setpos() to set the current position.
\end{DUlineblock}

\end{fulllineitems}

\index{lecimage() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.lecimage}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{lecimage}}}{\emph{s}, \emph{h}, \emph{b}, \emph{xcen}, \emph{ycen}, \emph{nx}, \emph{ny}}{}
Create an image array of the lobster eye cross-beam
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} size of cross-beam square area in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} height of cross-arm triangle in pixels (=2d/L)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{b}} \textendash{} jwidth of cross-arm triangle in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xcen}} \textendash{} centre pixel (see coords below)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ycen}} \textendash{} centre pixel (see coords below)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nx}} \textendash{} first dimension of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ny}} \textendash{} second dimension of array

\end{itemize}

\item[{Returns}] \leavevmode
image array

\end{description}\end{quote}
\begin{description}
\item[{Coordinate system for xcen,ycen is:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] x runs from 0.0 on left to nx on right
\item[] Y runs from 0.0 on bottom to ny on top
\item[] Centre of bottom left pixel is therefore 0.5,0.5
\item[] Centre of top right pixel is nx-0.5,ny-0.5
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{lepsf() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.lepsf}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{lepsf}}}{\emph{s}, \emph{h}, \emph{g}, \emph{eta}, \emph{xcen}, \emph{ycen}, \emph{nx}, \emph{ny}}{}
Create an image of the lobster eye PSF
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s}} \textendash{} size of cross-beam square area in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} height of cross-arm triangle in pixels (=2d/L)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{g}} \textendash{} width of Lorentzian central spot in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eta}} \textendash{} cross-arm to peak ratio at centre

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xcen}} \textendash{} centre of PSF (see below for coords. system)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ycen}} \textendash{} centre of PSF (see below for coords. system)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nx}} \textendash{} first dimension of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ny}} \textendash{} second dimension of array

\end{itemize}

\item[{Returns}] \leavevmode
image array

\end{description}\end{quote}
\begin{description}
\item[{Coordinate system for xcen,ycen is:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] x runs from 0.0 on left to nx on right
\item[] Y runs from 0.0 on bottom to ny on top
\item[] Centre of bottom left pixel is therefore 0.5,0.5
\item[] Centre of top right pixel is nx-0.5,ny-0.5
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{lorentzian() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.lorentzian}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{lorentzian}}}{\emph{x}, \emph{p}}{}
Lorentzian profile
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} array of x values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} array of fitting parameters

\end{itemize}

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] par 0: normalisation (value at peak)
\item[] par 1: x-centre (pixel position)
\item[] par 2: Lorentian width (pixels)
\end{DUlineblock}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
array of function values evaluated at x

\end{description}\end{quote}

\end{fulllineitems}

\index{peakchisq() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.peakchisq}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{peakchisq}}}{\emph{fpars}}{}
Chi-squared for image peak fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fpars}} \textendash{} array of fitting parameters

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] par 0: normalisation (value at peak)
\item[] par 1: x-centre (pixel position)
\item[] par 2: y-centre (pixel position)
\item[] par 3: Lorentian width (pixels) 24th Sept. 2017 RW
\end{DUlineblock}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Chi-squared value

\end{description}\end{quote}

Used by function beam() which loads Fortran common block BEAMFIT with image data.

\end{fulllineitems}

\index{plt\_show\_locator() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.plt_show_locator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{plt\_show\_locator}}}{\emph{fg}, \emph{npos}}{}
Get local coordinate positions using the cursor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fg}} \textendash{} figure id returned by plt.figure()

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{npos}} \textendash{} number of positions to be retured (clicked)

\end{itemize}

\item[{Returns}] \leavevmode
xx,yy,  2 arrays containing npos local coordinates

\end{description}\end{quote}

This routine provides a basic level of interaction with a displayed figure.
It is used in place of a simple plt.show() call so that npos local coordinate
positions can be selected interactively using the cursor from a displayed image
and returned in arrays to the user.

\end{fulllineitems}

\index{quaderr() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.quaderr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{quaderr}}}{\emph{x0}, \emph{y0}, \emph{x1}, \emph{y1}, \emph{y}}{}
Quadratic estimator for confidence limit
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x0}} \textendash{} parameter at minimum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y0}} \textendash{} statistic at minimum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x1}} \textendash{} parameter near minimum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y1}} \textendash{} statistic near minimum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} required statistic value

\end{itemize}

\item[{Returns}] \leavevmode
estimate of parameter corresponding to y

\end{description}\end{quote}

\end{fulllineitems}

\index{rectangles() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.rectangles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{rectangles}}}{\emph{x}, \emph{y}, \emph{w}, \emph{h}, \emph{t}}{}
Draw rectangles
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} centres in local x

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{y}} \textendash{} centres in local y

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{w}} \textendash{} widths

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} heights

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} rotation angles radians

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.reset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Reset common blocks to initial condition

\end{fulllineitems}

\index{setfield() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.setfield}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{setfield}}}{\emph{nx}, \emph{xleft}, \emph{xright}, \emph{ny}, \emph{ybot}, \emph{ytop}}{}
Set local coordinates for image field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nx}} \textendash{} number of columns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xleft}} \textendash{} local x left edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xright}} \textendash{} local x right edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ny}} \textendash{} number of rows

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ybot}} \textendash{} local y bottom edge

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ytop}} \textendash{} local y top edge

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{setpos() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.setpos}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{setpos}}}{\emph{ipos}, \emph{p}}{}
Set current position in image field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ipos}} \textendash{} coordinate index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} position coordinate pair

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{ipos values:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] 1: pixel 0-NCOLS, 0-NROWS
\item[] 2:  local X,Y
\item[] 3:  local azimuth,elevation degrees
\item[] 4:  Celestial RA,DEC degrees J2000
\item[] 5:  Ecliptic EA,EL degrees
\item[] 6:  Galactic LII,BII degrees
\end{DUlineblock}

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
current position using getpos()

\end{description}\end{quote}

\end{fulllineitems}

\index{setsky() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.setsky}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{setsky}}}{\emph{xtodeg}, \emph{ytodeg}, \emph{ipr}, \emph{mjd}, \emph{ra}, \emph{dec}, \emph{roll}}{}
Set up sky coordinates for image field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xtodeg}} \textendash{} scale from local x to degrees (usually -ve)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ytodeg}} \textendash{} scale from local y to degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ipr}} \textendash{} projection between local XY and local spherical

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mjd}} \textendash{} Modified Julian date

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ra}} \textendash{} Right Ascension (degrees J2000 at local origin)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dec}} \textendash{} Declination (degrees J2000 at local origin)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{roll}} \textendash{} Roll angle (degrees from North to +ve elev. +ve clockwise)

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{ipr values:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] 0: Plate Carre
\item[] 1: Aitoff (Hammer)
\item[] 2: Lambert (equatorial aspect of Azimuthal equal-area projection)
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{sqbeam() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.sqbeam}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{sqbeam}}}{\emph{arr}, \emph{hbeam}, \emph{blev}, \emph{bvar}}{}
Analysis of source above background within a square beam
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{arr}} \textendash{} image array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hbeam}} \textendash{} half width of square beam in pixels

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{blev}} \textendash{} average background level per pixel (to be subtracted)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bvar}} \textendash{} variance on blev (-ve for counting statistics)

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list with the following
\item[] \sphinxstylestrong{nx,ny}:    dimension of beam pixels (truncated if falls off edge)
\item[] \sphinxstylestrong{xpi,xpr}:  x output arrays, pixel position and flux
\item[] \sphinxstylestrong{ypi,ypr}:  y output arrays, pixel position and flux
\item[] \sphinxstylestrong{bflux}:    background in beam (e.g. counts)
\item[] \sphinxstylestrong{bsigma}:   standard deviation of background
\item[] \sphinxstylestrong{flux}:     source flux above background in beam (e.g. counts)
\item[] \sphinxstylestrong{fsigma}:   standard deviation of source flux
\item[] \sphinxstylestrong{peak}:     source x,y peak position
\item[] \sphinxstylestrong{cen}:      source x,y centroid position
\item[] \sphinxstylestrong{rmsx}:     rms width in x (pixels) about centroid
\item[] \sphinxstylestrong{rmsy}:     rms width in y (pixels) about centroid
\item[] \sphinxstylestrong{pi5}:      5\% x,y position
\item[] \sphinxstylestrong{pi25}:     25\% x,y position
\item[] \sphinxstylestrong{med}:      median (50\%) x,y position
\item[] \sphinxstylestrong{pi75}:     75\% x,y position
\item[] \sphinxstylestrong{pi95}:     95\% x,y position
\item[] \sphinxstylestrong{hewx}:     HEW (half energy width) x (pixels)
\item[] \sphinxstylestrong{hewy}:     HEW (half energy width) y (pixels)
\item[] \sphinxstylestrong{w90x}:     W90 (90\% width) x (pixels)
\item[] \sphinxstylestrong{w90y}:     W90 (90\% width) y (pixels)
\item[] \sphinxstylestrong{fitx}:     parameters from x profile fit using king\_profile()
\item[] \sphinxstylestrong{fity}:     parameters from y profile fit using king\_profile()
\end{DUlineblock}


\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] 
\item[] Fits performed if bvar!=0.
\item[] Parameters are saved in the lists fitx and fity
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 0: peak value (no error range calculated)
\item[] 1: peak X pixel position (no error range calculated)
\item[] 2: Lorentzian width including 90\% upper and lower bounds
\end{DUlineblock}
\item[] The position of the sqbeam is the current position within the image.
\item[] Use function setpos() to set the current position.
\end{DUlineblock}

\end{fulllineitems}

\index{srchmin() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.srchmin}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{srchmin}}}{\emph{pars}, \emph{pl}, \emph{ph}, \emph{stat}, \emph{delstat}, \emph{derr}}{}
Search for minimum statistic and return best fit parameters and confidence limits of the parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pars}} \textendash{} initial parameter values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} hard lower limit of parameter values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ph}} \textendash{} hard upper limit of parameter values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stat}} \textendash{} the statistic function to be minimised

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delstat}} \textendash{} the change in statistic for confidence limits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{derr}} \textendash{} initial error estimates for parameters, 0 fixed, \textgreater{}0 to estimate confidence range

\end{itemize}

\item[{Returns}] \leavevmode
list from optim() plus confidence limits parlo and parhi

\end{description}\end{quote}

The statistic function call must return the value of a statistic with call of form stat(pars) (e.g. images.peakchisq(pars))

\end{fulllineitems}

\index{toxy() (in module images)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{images_functions:images.toxy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{images.}}\sphinxbfcode{\sphinxupquote{toxy}}}{\emph{ipos}, \emph{p}}{}
Convert position to local xy coordinates
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ipos}} \textendash{} coordinate index

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] 1: pixel 0-NCOLS, 0-NROWS
\item[] 2: local X,Y
\item[] 3: local azimuth,elevation degrees
\item[] 4: Celestial RA,DEC degrees J2000
\item[] 5: Ecliptic EA,EL degrees
\item[] 6: Galactic LII,BII degrees
\end{DUlineblock}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
position as local xy

\end{description}\end{quote}

\end{fulllineitems}



\chapter{astro  - Astronomy Applications}
\label{\detokenize{astro:astro-astronomy-applications}}\label{\detokenize{astro::doc}}
X-ray spectra. X-ray spectral data are usually presented as histograms of
X-ray counts vs. energy (keV). The functions btoc() and ctob() provide conversion between energies at n bin centres and n+1 bin boundaries.
\begin{itemize}
\item {} 
brems() Bremsstrahlung spectrum

\item {} 
habs() X-ray absorption by a Hydrogen column density

\item {} 
setabnd() Set abundances for XSPEC routines used in absorption and optical depth calculations

\item {} 
btoc() Convert n+1 bin boundaries to n bin centres

\item {} 
ctob() Convert n bin centres to n+1 bin boundaries

\end{itemize}

X-ray optical depth. The local ISM and cosmic IGM gas is modelled as a hydrogen column including heavier elements at specified abundances and ionisation state.
\begin{itemize}
\item {} 
igmtau() X-ray optical depth of IGM gas

\item {} 
iigmtau() X-ray optical depth of ionized IGM gas

\item {} 
iigmtauvz() X-ray optical depth of ionized IGM gas vs. redshift

\item {} 
ismtau() X-ray optical depth of cold ISM gas

\item {} 
iismtau() X-ray optical depth of ionized ISM gas

\item {} 
lyftau() X-ray optical depth of Lyman Forest

\item {} 
lyftauvz() X-ray optical depth of Lyman Forest vs. redshift

\end{itemize}

Cosmology and redshift.
\begin{itemize}
\item {} 
cosmo() Calculation of cosmological quantities (luminosity distance etc.)

\item {} 
kcorrb() K-correction using numerical integration of the Band function

\end{itemize}


\section{astro.functions}
\label{\detokenize{astro_functions:module-astro}}\label{\detokenize{astro_functions:astro-functions}}\label{\detokenize{astro_functions::doc}}\index{astro (module)}\index{brems() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.brems}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{brems}}}{\emph{ekev}, \emph{t}}{}
Bremsstrahlung spectrum
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{t}} \textendash{} temperature keV

\end{itemize}

\item[{Returns}] \leavevmode
Bremsstrahlung continuum photons/keV at energies ekev

\end{description}\end{quote}

\end{fulllineitems}

\index{btoc() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.btoc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{btoc}}}{\emph{x}}{}
Convert n+1 bin boundaries to n bin centres
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} array of bin boundaries length n+1

\item[{Returns}] \leavevmode
array of bin centres length n

\end{description}\end{quote}

\end{fulllineitems}

\index{cosmo() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.cosmo}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{cosmo}}}{\emph{h0}, \emph{omegam}, \emph{omegal}, \emph{zmax}}{}
Calculation of cosmological quantities

\begin{DUlineblock}{0em}
\item[] Using equations from David Hogg astro-ph/9905116
\end{DUlineblock}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h0}} \textendash{} cosmological H0 km s-1 Mpc-1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegam}} \textendash{} cosmological omegam

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegal}} \textendash{} cosmological omegal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zmax}} \textendash{} maximum redshift

\end{itemize}

\item[{Returns}] \leavevmode
list with following sampled at dz=0.01

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{z}:      redshift values
\item[] \sphinxstylestrong{ez}:     scaling function
\item[] \sphinxstylestrong{dc}:     comoving line-of-sight distance
\item[] \sphinxstylestrong{dm}:     transverse comoving distance
\item[] \sphinxstylestrong{da}:     angular diameter distance
\item[] \sphinxstylestrong{dl}:     luminosity distance
\item[] \sphinxstylestrong{distm}:  distance modulus
\item[] \sphinxstylestrong{dvc}:    comoving volume element
\item[] \sphinxstylestrong{tlbak}:  look back time
\item[] \sphinxstylestrong{vc}:     integrated comoving volume over whole sky
\item[] \sphinxstylestrong{thsec}:  Hubble time in seconds
\item[] \sphinxstylestrong{thgyr}:  Hubble time in Giga years
\item[] \sphinxstylestrong{dhmpc}:  Hubble length in Mpc
\end{DUlineblock}

\end{fulllineitems}

\index{ctob() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.ctob}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{ctob}}}{\emph{x}}{}
Convert n bin centres to n+1 bin boundaries
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{x}} \textendash{} array of bin centres length n

\item[{Returns}] \leavevmode
array of bin boundaries length n+1

\end{description}\end{quote}

\end{fulllineitems}

\index{habs() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.habs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{habs}}}{\emph{cd}, \emph{ekev}}{}
X-ray absorption by a Hydrogen column density
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cd}} \textendash{} hydrogen column 10**21 cm-2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\end{itemize}

\item[{Returns}] \leavevmode
array of absorption factors

\end{description}\end{quote}

\end{fulllineitems}

\index{igmtau() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.igmtau}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{igmtau}}}{\emph{n0}, \emph{z}, \emph{h0}, \emph{omegam}, \emph{omegal}, \emph{ekev}}{}
X-ray optical depth of IGM gas
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n0}} \textendash{} number density cm-3 at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} redshift of source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h0}} \textendash{} cosmological H0 km s-1 Mpc-1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegam}} \textendash{} cosmological omegam

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegal}} \textendash{} cosmological omegal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\end{itemize}

\item[{Returns}] \leavevmode
optical depth for each energy

\end{description}\end{quote}

\end{fulllineitems}

\index{iigmtau() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.iigmtau}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{iigmtau}}}{\emph{n0}, \emph{pl}, \emph{tk}, \emph{ist}, \emph{z}, \emph{h0}, \emph{omegam}, \emph{omegal}, \emph{ekev}}{}
X-ray optical depth of ionized IGM gas
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n0}} \textendash{} number density cm-3 at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} powerlaw index of continuum spectrum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tk}} \textendash{} temperature Kelvin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ist}} \textendash{} ionization state L/nR\textasciicircum{}2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} redshift of source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h0}} \textendash{} cosmological H0 km s-1 Mpc-1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegam}} \textendash{} cosmological omegam

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegal}} \textendash{} cosmological omegal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\end{itemize}

\item[{Returns}] \leavevmode
optical depth for each energy

\end{description}\end{quote}

\end{fulllineitems}

\index{iigmtauvz() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.iigmtauvz}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{iigmtauvz}}}{\emph{n0}, \emph{dind}, \emph{m0}, \emph{mind}, \emph{pl}, \emph{tk}, \emph{ist}, \emph{h0}, \emph{omegam}, \emph{omegal}, \emph{ekev}, \emph{z}}{}
X-ray optical depth of ionized IGM gas vs. redshift
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n0}} \textendash{} number density cm-3 at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dind}} \textendash{} density index wrt z+1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{m0}} \textendash{} metalicity log{[}X/H{]} at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mind}} \textendash{} metalicity log{[}X/H{]} index wrt z

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} powerlaw index of continuum spectrum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tk}} \textendash{} temperature Kelvin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ist}} \textendash{} ionization state = L/nR\textasciicircum{}2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h0}} \textendash{} cosmological H0 km s-1 Mpc-1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegam}} \textendash{} cosmological omegam

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegal}} \textendash{} cosmological omegal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} energy keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} array of redshift values

\end{itemize}

\item[{Returns}] \leavevmode
optical depth at ekev for each redshift

\end{description}\end{quote}

\end{fulllineitems}

\index{iismtau() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.iismtau}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{iismtau}}}{\emph{nh}, \emph{z}, \emph{tk}, \emph{pl}, \emph{ist}, \emph{ekev}}{}
X-ray optical depth of ionized ISM gas
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nh}} \textendash{} column density 10**21 cm-3 at redshift z

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} redshift of source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tk}} \textendash{} temperature Kelvin

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} powerlaw index of continuum spectrum

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ist}} \textendash{} ionization state = L/nR\textasciicircum{}2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\end{itemize}

\end{description}\end{quote}

Returns:  optical depth for each energy

\end{fulllineitems}

\index{init() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.init}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{init}}}{}{}
Initialise common blocks on import

\end{fulllineitems}

\index{ismtau() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.ismtau}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{ismtau}}}{\emph{nh}, \emph{z}, \emph{ekev}}{}
X-ray optical depth of cold ISM gas
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nh}} \textendash{} column density 10**21 cm-2 at redshift z

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} redshift of source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\end{itemize}

\item[{Returns}] \leavevmode
optical depth for each energy

\end{description}\end{quote}

\end{fulllineitems}

\index{kcorrb() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.kcorrb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{kcorrb}}}{\emph{e1src}, \emph{e2src}, \emph{e1obs}, \emph{e2obs}, \emph{z}, \emph{gamma1}, \emph{gamma2}, \emph{ecobs}}{}
K-correction using numerical integration of Band function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{e1src}} \textendash{} lower source frame energy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{e2src}} \textendash{} upper source frame energy

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{e1obs}} \textendash{} array of lower observed energies

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{e2obs}} \textendash{} array of upper observed energies

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} array of redshifts

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma1}} \textendash{} array of observed photon indices below Ec

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma2}} \textendash{} array of observed photon indices above Ec

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ecobs}} \textendash{} array of observed Ec energies

\end{itemize}

\item[{Returns}] \leavevmode
list with the following for each object

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{kcorr}:  K-correction factor
\item[] \sphinxstylestrong{obint}:  integral over observed band
\item[] \sphinxstylestrong{boint}:  integral over Eiso band in observed frame
\end{DUlineblock}

\end{fulllineitems}

\index{lyftau() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.lyftau}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{lyftau}}}{\emph{n0}, \emph{dind}, \emph{m0}, \emph{mind}, \emph{z}, \emph{h0}, \emph{omegam}, \emph{omegal}, \emph{ekev}}{}
X-ray optical depth of Lyman Forest
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n0}} \textendash{} number density cm-3 at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dind}} \textendash{} density index wrt z+1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{m0}} \textendash{} metalicity log{[}X/H{]} at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mind}} \textendash{} metalicity log{[}X/H{]} index wrt z

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} redshift of source

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h0}} \textendash{} cosmological H0 km s-1 Mpc-1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegam}} \textendash{} cosmological omegam

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegal}} \textendash{} cosmological omegal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies keV

\end{itemize}

\item[{Returns}] \leavevmode
optical depth for each energy

\end{description}\end{quote}

\end{fulllineitems}

\index{lyftauvz() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.lyftauvz}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{lyftauvz}}}{\emph{n0}, \emph{dind}, \emph{m0}, \emph{mind}, \emph{h0}, \emph{omegam}, \emph{omegal}, \emph{ekev}, \emph{z}}{}
X-ray optical depth of Lyman Forest vs. z
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n0}} \textendash{} number density cm-3 at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dind}} \textendash{} density index wrt z+1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{m0}} \textendash{} metalicity log{[}X/H{]} at z=0

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mind}} \textendash{} metalicity log{[}X/H{]} index wrt z

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h0}} \textendash{} cosmological H0 km s-1 Mpc-1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegam}} \textendash{} cosmological omegam

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{omegal}} \textendash{} cosmological omegal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} photon energy keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{z}} \textendash{} array of redshifts

\end{itemize}

\item[{Returns}] \leavevmode
optical depth at ekev for each redshift

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.reset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Reset common blocks to initial condition

\end{fulllineitems}

\index{setabund() (in module astro)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{astro_functions:astro.setabund}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{astro.}}\sphinxbfcode{\sphinxupquote{setabund}}}{\emph{abun}, \emph{amet}}{}
Set abundances for XSPEC routines
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{abun}} \textendash{} XSPEC abundance table

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amet}} \textendash{} metalicity

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{xscat  - X-ray Physics}
\label{\detokenize{xscat:xscat-x-ray-physics}}\label{\detokenize{xscat::doc}}
X-ray optical constants.
\begin{itemize}
\item {} 
xopt() X-ray optical properties of a material

\item {} 
xfresnel() Calculate X-ray reflectivity using Fresnel’s equations

\end{itemize}

X-ray scattering by dust.
\begin{itemize}
\item {} 
dustrings() Model fitting to dust X-ray scattering halo rings

\item {} 
duststat() Statistic of fit of model to dust rings

\item {} 
dustthetascat() Scattering angle radians

\item {} 
miev0() Wiscombe subroutine for Mie scattering calculations

\end{itemize}


\section{xscat.functions}
\label{\detokenize{xscat_functions:module-xscat}}\label{\detokenize{xscat_functions:xscat-functions}}\label{\detokenize{xscat_functions::doc}}\index{xscat (module)}\index{dustrings() (in module xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.dustrings}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{dustrings}}}{\emph{data}, \emph{derr}, \emph{dsou}, \emph{ekv}, \emph{srate}, \emph{dts}, \emph{td}, \emph{zd}, \emph{amin}, \emph{amax}, \emph{qa}, \emph{sig1}}{}
Model fitting to dust X-ray scattering halo rings
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{data}} \textendash{} data array of rings surface brightness cts/s/str

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{derr}} \textendash{} array of errors on data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dsou}} \textendash{} distance to source PC

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekv}} \textendash{} array of energies keV (equally spaced across observed band)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{srate}} \textendash{} source spectrum cts/s/keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dts}} \textendash{} source burst duration

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{td}} \textendash{} delay time of observations secs

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zd}} \textendash{} fraction of source distance to rings

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amin}}\sphinxstyleliteralstrong{\sphinxupquote{,}}\sphinxstyleliteralstrong{\sphinxupquote{amax}} \textendash{} grain size radius range microns

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{qa}} \textendash{} grain size distribution index N(a)=A.a\textasciicircum{}-qa

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sig1}} \textendash{} differential cross-section of 1 grain cm2, 1 keV, 0.1 microns

\end{itemize}

\item[{Returns}] \leavevmode
the following

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{angs}:       array of angles
\item[] \sphinxstylestrong{ndust}:      N dust columns cm-2
\item[] \sphinxstylestrong{edust}:      errors on N dust columns cm-2
\item[] \sphinxstylestrong{model}:      model cts/s/str in rings
\item[] \sphinxstylestrong{chisq}:      Chi-Squared between data and model
\item[] \sphinxstylestrong{ndof}:       ndof
\end{DUlineblock}

\end{fulllineitems}

\index{duststat (class in xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.duststat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{duststat}}}{\emph{data}, \emph{derr}, \emph{dsou}, \emph{ekv}, \emph{srate}, \emph{dts}, \emph{td}, \emph{zd}, \emph{sig1}}{}
Statistic of fit of model to dust rings

\end{fulllineitems}

\index{dustthetascat() (in module xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.dustthetascat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{dustthetascat}}}{\emph{td}, \emph{ds}, \emph{zd}}{}
Scattering angle radians
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{td}} \textendash{} delay time seconds after source flare (assumed delta function)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ds}} \textendash{} distance to source parsecs (convert to m - 3.086e16/parsec)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zd}} \textendash{} fractional distance to dust

\end{itemize}

\item[{Returns}] \leavevmode
angle in radians

\end{description}\end{quote}

\end{fulllineitems}

\index{miev0() (in module xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.miev0}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{miev0}}}{\emph{xx}, \emph{crefin}, \emph{pfct}, \emph{mimc}, \emph{anya}, \emph{xmu}, \emph{nmom}, \emph{ipolzn}, \emph{momd}, \emph{prt}}{}
\sphinxhref{https://github.com/cfinch/Mie\_scattering/blob/master/Wiscombe/MIEV0.f}{Wiscombe subroutine}

Computes Mie scattering and extinction efficiencies; asymmetry
factor;  forward- and backscatter amplitude;  scattering
amplitudes vs. scattering angle for incident polarization parallel
and perpendicular to the plane of scattering;
coefficients in the Legendre polynomial expansions of either the
unpolarized phase function or the polarized phase matrix;
some quantities needed in polarized radiative transfer;  and
information about whether or not a resonance has been hit.

Input and output variables are described in file MIEV.doc.
Many statements are accompanied by comments referring to
references in MIEV.doc, notably the NCAR Mie report which is now
available electronically and which is referred to using the
shorthand (Rn), meaning Eq. (n) of the report.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xx}} \textendash{} Mie size parameter ( 2 * pi * radius / wavelength )

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{crefin}} \textendash{} Complex refractive index ( imag part can be + or -,
but internally a negative imaginary index is assumed ).
If imag part is - ,  scattering amplitudes as in Van
de Hulst are returned;  if imag part is + , complex
conjugates of those scattering amplitudes are returned
(the latter is the convention in physics).
** NOTE ** In the ‘PERFECT’ case, scattering amplitudes
in the Van de Hulst (Ref. 6 above) convention will
automatically be returned unless  Im(CREFIN)  is
positive;  otherwise, CREFIN plays no role.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pfct}} \textendash{} TRUE, assume refractive index is infinite and use
special case formulas for Mie coefficients  ‘a’
and  ‘b’  ( see Kerker, M., The Scattering of
Light and Other Electromagnetic Radiation, p. 90 ).
This is sometimes called the ‘totally reflecting’,
sometimes the ‘perfectly conducting’ case.
( see CREFIN for additional information )

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mimc}} \textendash{} (positive) value below which imaginary refractive
index is regarded as zero (computation proceeds
faster for zero imaginary index)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{anya}} \textendash{} TRUE, any angles whatsoever may be input through
XMU.  FALSE, the angles are monotone increasing
and mirror symmetric about 90 degrees (this option
is advantageous because the scattering amplitudes
S1,S2 for the angles between 90 and 180 degrees
are evaluable from symmetry relations, and hence
are obtained with little added computational cost.)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{numang}} \textendash{} No. of angles at which scattering amplitudes
S1,S2 are to be evaluated  ( set = 0 to skip
calculation of S1,S2 ).  Make sure NUMANG does
not exceed the parameter MAXANG in the program.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xmu}} (\sphinxstyleliteralemphasis{\sphinxupquote{N}}) \textendash{} Cosines of angles ( N = 1 TO NUMANG ) at which S1,S2
are to be evaluated.  If ANYANG = FALSE, then
(a) the angles must be monotone increasing and
mirror symmetric about 90 degrees (if 90-A is
an angle, then 90+A must be also)
(b) if NUMANG is odd, 90 degrees must be among
the angles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nmom}} \textendash{} Highest Legendre moment PMOM to calculate,
numbering from zero ( NMOM = 0 prevents
calculation of PMOM )

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ipolzn}} \textendash{} POSITIVE, Compute Legendre moments PMOM for the
Mueller matrix elements determined by the
digits of IPOLZN, with 1 referring to M1,
2 to M2, 3 to S21, and 4 to D21 (Ref. 3).
E.g., if IPOLZN = 14 then only moments for
M1 and D21 will be returned.
0,  Compute Legendre moments PMOM for the
npolarized unnormalized phase function.
NEGATIVE, Compute Legendre moments PMOM for the
Sekera phase quantities determined by the
digits of ABS(IPOLZN), with 1 referring to
R1, 2 to R2, 3 to R3, and 4 to R4 (REF. 4).
E.g., if IPOLZN = -14 then only moments for
R1 and R4 will be returned.
( NOT USED IF  NMOM = 0 )

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{momd}} \textendash{} Determines first dimension of PMOM, which is dimensioned
internally as PMOM( 0:MOMDIM, * ) (second dimension must
be the larger of unity and the highest digit in
IPOLZN; if not, serious errors will occur).
Must be given a value, even if  NMOM = 0.  Minimum: 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prt}} (\sphinxstyleliteralemphasis{\sphinxupquote{L}}) \textendash{} Print flags (LOGICAL).  L = 1  prints  S1,S2, their
squared absolute values, and degree of polarization,
provided NUMANG is non-zero.   L = 2  prints all
output variables other than  S1,S2.

\end{itemize}

\item[{Returns}] \leavevmode
list containing the following

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{qext}:       (REAL) extinction efficiency factor  ( Ref. 2, Eq. 1A )
\item[] \sphinxstylestrong{qsca}:       (REAL) scattering efficiency factor  ( Ref. 2, Eq. 1B )
\item[] \sphinxstylestrong{gqsc}:       (REAL) asymmetry factor times scattering efficiency
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] ( Ref. 2, Eq. 1C )  ( allows calculation of radiation
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] pressure efficiency factor  QPR = QEXT - GQSC )
\end{DUlineblock}
\item[] NOTE \textendash{} S1, S2, SFORW, SBACK, TFORW, AND TBACK are calculated
\item[] internally for negative imaginary refractive index;
\item[] for positive imaginary index, their complex conjugates
\item[] are taken before they are returned, to correspond to
\item[] customary usage in some parts of physics ( in particular,
\item[] in papers on CAM approximations to Mie theory ).
\end{DUlineblock}
\item[] \sphinxstylestrong{pmom(M,NP)}: (REAL) moments  M = 0 to NMOM  of unnormalized NP-th
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] phase quantity PQ  ( moments with  M .GT. 2*NTRM  are
\item[] zero, where  NTRM = no. terms in Mie series =
\item[] XX + 4*XX**1/3 + 1 )
\end{DUlineblock}
\item[] \sphinxstylestrong{PQ( MU, NP )}: = sum( M=0 to infinity ) ( (2M+1)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] * PMOM( M,NP ) * P-sub-M( MU ) )
\item[] WHERE  MU = COS( scattering angle )
\item[] P-sub-M = M-th Legendre polynomial
\item[] and the definition of ‘PQ’ is as follows:
\item[] IPOLZN.GT.0:  PQ(MU,1) = CABS( S1(MU) )**2
\item[] PQ(MU,2) = CABS( S2(MU) )**2
\item[] PQ(MU,3) = RE( S1(MU)*CONJG( S2(MU) ) )
\item[] PQ(MU,4) = - IM( S1(MU)*CONJG( S2(MU) ) )
\item[] ( called M1, M2, S21, D21 in literature )
\item[] IPOLZN=0:  PQ(MU,1) = ( CABS(S1)**2 + CABS(S2)**2 ) / 2
\item[] ( the unnormalized phase function )
\item[] IPOLZN.LT.0:  PQ(MU,1) = CABS( T1(MU) )**2
\item[] PQ(MU,2) = CABS( T2(MU) )**2
\item[] PQ(MU,3) = RE( T1(MU)*CONJG( T2(MU) ) )
\item[] PQ(MU,4) = - IM( T1(MU)*CONJG( T2(MU) ) )
\item[] ( called R1, R2, R3, R4 in literature )
\item[] The sign of the 4th phase quantity is a source of
\item[] confusion.  It flips if the complex conjugates of
\item[] S1,S2  or  T1,T2  are used, as occurs when a
\item[] refractive index with positive imaginary part is
\item[] used (see discussion below).  The definition above
\item[] is consistent with a negative imaginary part.
\item[] See Ref. 5 for correct formulae for PMOM ( Eqs. 2-5
\item[] of Ref. 3 contain typographical errors ).  Ref. 5 also
\item[] contains numerous improvements to the Ref. 3 formulas.
\item[] NOTE THAT OUR DEFINITION OF MOMENTS DIFFERS FROM REF. 3
\item[] in that we divide out the factor (2M+1) and number the
\item[] moments from zero instead of one.
\item[] ** WARNING **  Make sure the second dimension of PMOM
\item[] in the calling program is at least as large as the
\item[] absolute value of IPOLZN.
\item[] For small enough values of XX, or large enough values
\item[] of M,  PMOM  will tend to underflow.  Thus, it is
\item[] unwise to assume the values returned are non-zero and,
\item[] for example, to divide some quantity by them.
\end{DUlineblock}
\item[] \sphinxstylestrong{s1(N),s2(N)}:  (COMPLEX) Mie scattering amplitudes at angles specified
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] by XMU(N) ( N=1 to NUMANG )  ( Ref. 2, Eqs. 1d-e ).
\end{DUlineblock}
\item[] \sphinxstylestrong{sforw}:  (COMPLEX) forward-scattering amplitude S1 at
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 0 degrees.  ( S2(0 deg) = S1(0 deg) )
\end{DUlineblock}
\item[] \sphinxstylestrong{sback}:  (COMPLEX) backscattering amplitude S1 at
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 180 degrees.   ( S2(180 deg) = - S1(180 deg) )
\end{DUlineblock}
\item[] \sphinxstylestrong{tforw(I)}:   (COMPLEX) values of
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] I=1:  T1 = ( S2 - (MU)*S1 ) / ( 1 - MU**2 )
\item[] I=2:  T2 = ( S1 - (MU)*S2 ) / ( 1 - MU**2 )
\item[] At angle theta = 0 ( MU = COS(theta) = 1 ), where the
\item[] expressions on the right-hand side are indeterminate.
\item[] ( these quantities are required for doing polarized
\item[] radiative transfer (Ref. 4, Appendix). )
\end{DUlineblock}
\item[] \sphinxstylestrong{tback(I)}:   (COMPLEX) values of  T1 (for I=1) or  T2 (for I=2) at
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] angle  theta = 180 degrees ( MU = COS(theta) = - 1 ).
\end{DUlineblock}
\item[] \sphinxstylestrong{spike}:     (REAL) magnitude of the smallest denominator of
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] either Mie coefficient (a-sub-n or b-sub-n),
\item[] taken over all terms in the Mie series past
\item[] N = size parameter XX.  Values of SPIKE below
\item[] about 0.3 signify a ripple spike, since these
\item[] spikes are produced by abnormally small denominators
\item[] in the Mie coefficients (normal denominators are of
\item[] order unity or higher).  Defaults to 1.0 when not
\item[] on a spike.  Does not identify all resonances
\item[] (we are still working on that).
\end{DUlineblock}
\end{DUlineblock}

\end{fulllineitems}

\index{mievs (class in xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.mievs}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{mievs}}}
Mie scattering and Rayleigh-Gans approximation for scattering by dust
\index{list() (xscat.mievs method)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.mievs.list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{list}}}{}{}
List object

\end{fulllineitems}


\end{fulllineitems}

\index{xfresnel() (in module xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.xfresnel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{xfresnel}}}{\emph{alpha}, \emph{gamma}, \emph{angs}}{}
Calculate X-ray reflectivity using Fresnel’s equations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} real incremental part dielectric constant

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} imaginary part of dielectric constant

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{angs}} \textendash{} incidence angles (degrees)

\end{itemize}

\item[{Returns}] \leavevmode


\item[{Return type}] \leavevmode
list of following

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{rs}:       sigma reflectivity
\item[] \sphinxstylestrong{rp}:       pi reflectivity
\item[] \sphinxstylestrong{runp}:     unpolarized reflectivity
\end{DUlineblock}

If angs(I) out of range 0-90 degrees returns zero reflectivity

\end{fulllineitems}

\index{xopt() (in module xscat)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xscat_functions:xscat.xopt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xscat.}}\sphinxbfcode{\sphinxupquote{xopt}}}{\emph{mspec}, \emph{rho}, \emph{ekev}, \emph{itype}}{}
X-ray optical properties of a material
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mspec}} \textendash{} specification of composition

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rho}} \textendash{} density gm/cm**3

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekev}} \textendash{} array of photon energies in keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{itype}} \textendash{} data source (0=Cromer, 1=Henke)

\end{itemize}

\item[{Returns}] \leavevmode
list with the following

\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{alpha}:     array of real parts dielectric constant
\item[] \sphinxstylestrong{gamm}:      array of imaginary parts dielectric constant
\item[] \sphinxstylestrong{absl}:      array of absortion lengths cm-1
\item[] \sphinxstylestrong{f1}:        array of real parts scattering factor
\item[] \sphinxstylestrong{f2}:        array of imaginary parts scattering factor
\end{DUlineblock}

\end{fulllineitems}



\chapter{xsrt   - Sequential Ray Tracing}
\label{\detokenize{xsrt:xsrt-sequential-ray-tracing}}\label{\detokenize{xsrt::doc}}
The code was written for modelling grazing incidence X-ray telescopes but it
works at normal incidence and includes many common optical elements.

The code is \sphinxstyleemphasis{sequential} in the sense
that rays encounter the optical elements in the order that they are specified.
However, by setting flags associated
with each element the sequence can be controlled dynamically to handle
multiple interactions, between different optical elements, in any sequence.


\section{Example Scripts}
\label{\detokenize{xsrt_example_scripts:example-scripts}}\label{\detokenize{xsrt_example_scripts::doc}}
The following Python and R scripts illustrate how the ray tracing is done.

The sequence of elements is:
\begin{quote}

source \textendash{}\textgreater{} mirrors/stops/lenses/gratings/etc. \textendash{}\textgreater{} detector
\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/env python}
\PYG{c+c1}{\PYGZsh{} Use Swift XRT geometry as an example}
\PYG{k+kn}{from} \PYG{n+nn}{\PYGZus{}\PYGZus{}future\PYGZus{}\PYGZus{}} \PYG{k+kn}{import} \PYG{n}{print\PYGZus{}function}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{images}
\PYG{k+kn}{import} \PYG{n+nn}{xsrt}
\PYG{c+c1}{\PYGZsh{} Useful vectors}
\PYG{n}{sn}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{nn}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{rx}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Set look\PYGZhy{}up table reflectivity to 1.0}
\PYG{n}{angs}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{refs}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Support spiders}
\PYG{n}{spi}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{3838.8}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{tp}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3800}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{conea}\PYG{o}{=}\PYG{l+m+mf}{10.05}
\PYG{n}{nsec}\PYG{o}{=}\PYG{l+m+mi}{12}
\PYG{n}{cwid}\PYG{o}{=} \PYG{l+m+mf}{0.0}
\PYG{n}{awid}\PYG{o}{=} \PYG{l+m+mf}{3.0}
\PYG{n}{edf2}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{3200}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{edf1}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{3161.2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Wolter I shell parameters}
\PYG{n}{fl}\PYG{o}{=} \PYG{l+m+mi}{3500}
\PYG{n}{ph}\PYG{o}{=} \PYG{l+m+mi}{3800}
\PYG{n}{hl}\PYG{o}{=} \PYG{l+m+mi}{3200}
\PYG{n}{ra}\PYG{o}{=} \PYG{l+m+mf}{1.0}
\PYG{n}{ns}\PYG{o}{=} \PYG{l+m+mi}{13}
\PYG{n}{rj}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{146.880}\PYG{p}{,}\PYG{l+m+mf}{140.980}\PYG{p}{,}\PYG{l+m+mf}{135.320}\PYG{p}{,}\PYG{l+m+mf}{129.890}\PYG{p}{,}\PYG{l+m+mf}{124.670}\PYG{p}{,}\PYG{l+m+mf}{119.660}\PYG{p}{,}\PYG{l+m+mf}{114.850}\PYG{p}{,}
\PYG{l+m+mf}{110.240}\PYG{p}{,}\PYG{l+m+mf}{105.810}\PYG{p}{,}\PYG{l+m+mf}{101.560}\PYG{p}{,}\PYG{l+m+mf}{97.490}\PYG{p}{,}\PYG{l+m+mf}{93.560}\PYG{p}{,}\PYG{l+m+mf}{90.833}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{tt}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{1.25}\PYG{p}{,}\PYG{l+m+mf}{1.20}\PYG{p}{,}\PYG{l+m+mf}{1.15}\PYG{p}{,}\PYG{l+m+mf}{1.10}\PYG{p}{,}\PYG{l+m+mf}{1.05}\PYG{p}{,}\PYG{l+m+mf}{1.00}\PYG{p}{,}\PYG{l+m+mf}{0.95}\PYG{p}{,}\PYG{l+m+mf}{0.90}\PYG{p}{,}\PYG{l+m+mf}{0.85}\PYG{p}{,}\PYG{l+m+mf}{0.80}\PYG{p}{,}\PYG{l+m+mf}{0.75}\PYG{p}{,}\PYG{l+m+mf}{0.70}\PYG{p}{,}\PYG{l+m+mf}{0.70}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Source}
\PYG{n}{di}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{rlim}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{92.0}\PYG{p}{,}\PYG{l+m+mf}{151.0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{nray}\PYG{o}{=} \PYG{l+m+mi}{10000}
\PYG{c+c1}{\PYGZsh{} Detector}
\PYG{n}{rdet}\PYG{o}{=} \PYG{l+m+mi}{30}
\PYG{n}{dlim}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rdet}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{dpos}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} image paramters}
\PYG{n}{nx}\PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{ny}\PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{hwid}\PYG{o}{=} \PYG{l+m+mf}{5.0}
\PYG{c+c1}{\PYGZsh{} Ray tracing calls}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{reset}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{source}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{di}\PYG{p}{,}\PYG{n}{nn}\PYG{p}{,}\PYG{n}{spi}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{rlim}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{nray}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{surface}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{angs}\PYG{p}{,}\PYG{n}{refs}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{spider}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{conea}\PYG{p}{,}\PYG{n}{spi}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{nsec}\PYG{p}{,}\PYG{n}{cwid}\PYG{p}{,}\PYG{n}{awid}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{spider}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{tp}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{nsec}\PYG{p}{,}\PYG{n}{cwid}\PYG{p}{,}\PYG{n}{awid}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{w1nest}\PYG{p}{(}\PYG{n}{fl}\PYG{p}{,}\PYG{n}{rj}\PYG{p}{,}\PYG{n}{ra}\PYG{p}{,}\PYG{n}{fl}\PYG{p}{,}\PYG{n}{ph}\PYG{p}{,}\PYG{n}{hl}\PYG{p}{,}\PYG{n}{fl}\PYG{p}{,}\PYG{n}{tt}\PYG{p}{,}\PYG{n}{tt}\PYG{p}{,}\PYG{n}{tt}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{nn}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{spider}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{n}{edf2}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{nsec}\PYG{p}{,}\PYG{n}{cwid}\PYG{p}{,}\PYG{n}{awid}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{spider}\PYG{p}{(}\PYG{n}{conea}\PYG{p}{,}\PYG{n}{edf1}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{nsec}\PYG{p}{,}\PYG{n}{cwid}\PYG{p}{,}\PYG{n}{awid}\PYG{p}{)}
\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{detector}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{dpos}\PYG{p}{,}\PYG{n}{sn}\PYG{p}{,}\PYG{n}{rx}\PYG{p}{,}\PYG{n}{dlim}\PYG{p}{,}\PYG{l+m+mf}{0.0}\PYG{p}{)}
\PYG{n}{results}\PYG{o}{=}\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{trace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rdet}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create an image of the detected area}
\PYG{n}{XD}\PYG{p}{,}\PYG{n}{YD}\PYG{p}{,}\PYG{n}{ZD}\PYG{p}{,}\PYG{n}{XC}\PYG{p}{,}\PYG{n}{YC}\PYG{p}{,}\PYG{n}{ZC}\PYG{p}{,}\PYG{n}{XR}\PYG{p}{,}\PYG{n}{YR}\PYG{p}{,}\PYG{n}{ZR}\PYG{p}{,}\PYG{n}{YDET}\PYG{p}{,}\PYG{n}{ZDET}\PYG{p}{,}\PYG{n}{AREA}\PYG{p}{,}\PYG{n}{IREF}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{detected.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{skiprows}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{unpack}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{arr}\PYG{o}{=}\PYG{n}{images}\PYG{o}{.}\PYG{n}{binxy}\PYG{p}{(}\PYG{n}{YDET}\PYG{p}{,}\PYG{n}{ZDET}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{AREA}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Analyse beam to get total collecting area}
\PYG{n}{images}\PYG{o}{.}\PYG{n}{setfield}\PYG{p}{(}\PYG{n}{nx}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{)}
\PYG{n}{images}\PYG{o}{.}\PYG{n}{setpos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{bb}\PYG{o}{=}\PYG{n}{images}\PYG{o}{.}\PYG{n}{beam}\PYG{p}{(}\PYG{n}{a}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{area}\PYG{o}{=}\PYG{n}{bb}\PYG{o}{.}\PYG{n}{flux}\PYG{o}{/}\PYG{l+m+mf}{100.}
\PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{area cm\PYGZca{}2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{area}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}!/usr/bin/env Rscript}
\PYG{c+c1}{\PYGZsh{} Use Swift XRT geometry as an example}
\PYG{c+c1}{\PYGZsh{} Useful vectors}
sn\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
nn\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
rx\PYG{o}{\PYGZlt{}\PYGZhy{}}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Set look\PYGZhy{}up table reflectivity to 1.0}
angs\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{90}\PYG{p}{)}
refs\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{1}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Support spiders}
spi\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{3838.8}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
tp\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{3800}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
conea\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{10.05}
nsec\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{12}
cwid\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{0.0}
awid\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{3.0}
edf2\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{3200}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
edf1\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{3161.2}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Wolter I shell parameters}
fl\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{3500}
ph\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{3800}
hl\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{3200}
ra\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{1.0}
ns\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{13}
rj\PYG{o}{\PYGZlt{}\PYGZhy{}}   \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{146.880}\PYG{p}{,}\PYG{l+m}{140.980}\PYG{p}{,}\PYG{l+m}{135.320}\PYG{p}{,}\PYG{l+m}{129.890}\PYG{p}{,}\PYG{l+m}{124.670}\PYG{p}{,}\PYG{l+m}{119.660}\PYG{p}{,}\PYG{l+m}{114.850}\PYG{p}{,}\PYG{l+m}{110.240}\PYG{p}{,}
\PYG{l+m}{105.810}\PYG{p}{,}\PYG{l+m}{101.560}\PYG{p}{,}\PYG{l+m}{97.490}\PYG{p}{,}\PYG{l+m}{93.560}\PYG{p}{,}\PYG{l+m}{90.833}\PYG{p}{)}
tt\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{1.25}\PYG{p}{,}\PYG{l+m}{1.20}\PYG{p}{,}\PYG{l+m}{1.15}\PYG{p}{,}\PYG{l+m}{1.10}\PYG{p}{,}\PYG{l+m}{1.05}\PYG{p}{,}\PYG{l+m}{1.00}\PYG{p}{,}\PYG{l+m}{0.95}\PYG{p}{,}\PYG{l+m}{0.90}\PYG{p}{,}\PYG{l+m}{0.85}\PYG{p}{,}\PYG{l+m}{0.80}\PYG{p}{,}\PYG{l+m}{0.75}\PYG{p}{,}\PYG{l+m}{0.70}\PYG{p}{,}\PYG{l+m}{0.70}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Source}
di\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
rlim\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{92.0}\PYG{p}{,}\PYG{l+m}{151.0}\PYG{p}{)}
nray\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{10000}
\PYG{c+c1}{\PYGZsh{} Detector}
rdet\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{30}
dlim\PYG{o}{=}\PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}rdet\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
dpos\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{k+kt}{c}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} image paramters}
nx\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{100}
ny\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{100}
hwid\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{5.0}
\PYG{c+c1}{\PYGZsh{} Ray tracing calls}
qrt\PYGZus{}reset\PYG{p}{(}\PYG{p}{)}
qrt\PYGZus{}source\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}di\PYG{p}{,}nn\PYG{p}{,}spi\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}rlim\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}nray\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
qrt\PYGZus{}surface\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{2}\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{,}angs\PYG{p}{,}refs\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
qrt\PYGZus{}spider\PYG{p}{(}\PYG{o}{\PYGZhy{}}conea\PYG{p}{,}spi\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}nsec\PYG{p}{,}cwid\PYG{p}{,}awid\PYG{p}{)}
qrt\PYGZus{}spider\PYG{p}{(}\PYG{l+m}{0.0}\PYG{p}{,}tp\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}nsec\PYG{p}{,}cwid\PYG{p}{,}awid\PYG{p}{)}
qrt\PYGZus{}w1nest\PYG{p}{(}fl\PYG{p}{,}rj\PYG{p}{,}ra\PYG{p}{,}fl\PYG{p}{,}ph\PYG{p}{,}hl\PYG{p}{,}fl\PYG{p}{,}tt\PYG{p}{,}tt\PYG{p}{,}tt\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}nn\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{1}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
qrt\PYGZus{}spider\PYG{p}{(}\PYG{l+m}{0.0}\PYG{p}{,}edf2\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}nsec\PYG{p}{,}cwid\PYG{p}{,}awid\PYG{p}{)}
qrt\PYGZus{}spider\PYG{p}{(}conea\PYG{p}{,}edf1\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}nsec\PYG{p}{,}cwid\PYG{p}{,}awid\PYG{p}{)}
qrt\PYGZus{}detector\PYG{p}{(}\PYG{l+m}{1}\PYG{p}{,}dpos\PYG{p}{,}sn\PYG{p}{,}rx\PYG{p}{,}dlim\PYG{p}{,}\PYG{l+m}{0.0}\PYG{p}{)}
results\PYG{o}{\PYGZlt{}\PYGZhy{}} qrt\PYGZus{}trace\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}rdet\PYG{p}{,}\PYG{l+m}{\PYGZhy{}2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create an image of the detected area}
detpos\PYG{o}{\PYGZlt{}\PYGZhy{}}read.table\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{detected.dat\PYGZdq{}}\PYG{p}{,}header\PYG{o}{=}\PYG{k+kc}{TRUE}\PYG{p}{)}
a\PYG{o}{\PYGZlt{}\PYGZhy{}}qri\PYGZus{}binxy\PYG{p}{(}detpos\PYG{o}{\PYGZdl{}}YDET\PYG{p}{,}detpos\PYG{o}{\PYGZdl{}}ZDET\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}detpos\PYG{o}{\PYGZdl{}}AREA\PYG{p}{,}\PYG{o}{\PYGZhy{}}hwid\PYG{p}{,}hwid\PYG{p}{,}nx\PYG{p}{,}\PYG{o}{\PYGZhy{}}hwid\PYG{p}{,}hwid\PYG{p}{,}ny\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Analyse beam to get total collecting area}
bb\PYG{o}{\PYGZlt{}\PYGZhy{}}qri\PYGZus{}beam\PYG{p}{(}a\PYG{o}{\PYGZdl{}}data\PYGZus{}array\PYG{p}{,}hwid\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{)}
area\PYG{o}{\PYGZlt{}\PYGZhy{}}bb\PYG{o}{\PYGZdl{}}flux\PYG{o}{/}\PYG{l+m}{100}\PYG{l+m}{.}
\PYG{k+kp}{cat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{area cm\PYGZca{}2\PYGZdq{}}\PYG{p}{,}area\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZbs{}n\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Optical Elements and Coordinates}
\label{\detokenize{xsrt_elements:optical-elements-and-coordinates}}\label{\detokenize{xsrt_elements::doc}}
Each of the elements, including the source and detector, are specified
by:
\begin{itemize}
\item {} 
3 surface reference vectors - origin position, surface normal at origin and reference tangent at origin

\item {} 
The surface figure - planar, spherical or conic section - parameters to define the curvature etc. of the figure

\item {} 
The surface boundary - circles or rectangles in local surface coordinates

\item {} 
A surface quality - source of rays, detection, reflection, diffraction, scattering, refraction, absorption

\item {} 
The surface deformation - a grid of displacements defined in local surface coordinates

\end{itemize}

A full list of all the currently defined elements is produced by the
function srtlist().

Individual elements referenced by the surface element index
can be shifted and rotated using shift() and rotate().

The data base of elements can be cleared to the initial condition (no
elements defined) using the function reset(). If elements are
repeatedly defined within a procedure (for instance within a loop)
the safe and prefered option is to reset()
everything and redefine all elements each time they are required.

\sphinxstylestrong{Coordinates}

There is no fixed coordinate system and elements can be set/defined at
any orientation. However it is conventional to use the X-axis as the
optical axis (which defines the direction of paraxial rays) and the
Y-axis as the nominal tangent reference axis. Of course given elements
may not be aligned exactly with the X-axis and Y-axis.
In most cases the local coordinates in the detector plane are nominally
aligned with the Y-axis and Z-axis. Rays are usually traced from right
to left travelling in the -X direction but this is not necessary and
it is possible for rays to bounce back and forth as in, for example,
a cassegrain system.

The source is always the first element in the sequence. All other
elements are placed in sequence as they are defined. If the source()
function is used repeatedly the source specification will be overwritten
each time.
If the detector command is used repeatedly a new detector will be
added to the sequence each time and all detectors defined will be active.

Local surface coordinates
are specified using the tangent plane
to the surface at the point defined as the surface origin. For a sphere
points on this tangent plane are projected
onto the surface along the normal to the surface at the surface
origin (Lambert’s projection). The local x-axis is specified by a tangent vector
at the surface origin. The local y-axis is the cross product of the
normal and tangent vector at the surface origin.

The coordinates used for the limits of apertures and stops are given
in the docstrings of the xsrt.aperture() function.

The local coordinates used for surfaces of revolution generated from conic
sections (hyperbola, parabola, ellipse) depend on whether the surface
is designated as being “normal” or “grazing” incidence. For normal
incidence they are defined in a similar way to the planar or spherical
surfaces as given above. For grazing incidence a cylindrical coordinate
system is used where the axis is the normal to the surface at
the surface origin and the azimuth is the rotation about this axis
with zero at the surface reference axis at the surface origin. Local
coordinates are given as axial position and azimuthal position (radians).
The limits of such surfaces are specified by axial and/or radial limits
corresponding to the bottom and top edges of the surface of revolution.


\section{Source and Detector}
\label{\detokenize{xsrt_source_detector:source-and-detector}}\label{\detokenize{xsrt_source_detector::doc}}
\sphinxstylestrong{Source of Rays}

The source of rays consists of an annular or rectangular aperture on a planar
surface. The origin of each ray is a random point within
the aperture. The direction of the rays is specified either by
a source at infinity, a source at a finite distance or diffuse.
For a source at infinity all rays are parallel with the direction
set by direction cosines. A source at a finite distance is specified
by a position vector somewhere behind the aperture. Diffuse rays
are generated so as to give a uniform random distribution over a hemisphere.
The total number of rays generated is either set explicitly or by
using an aperture area per ray.

Only one source can be specified. If the source command is used in a
loop then the source will change on each pass through the loop.

The deformation index is used to specify a pixel array which spreads
out a point source into an angular distribution. The deformation data are
set using two functions xsrt.deform() and xsrt.defmat().
If the source is at infinity the x and y sample arrays must be in radians
measured from the direction \sphinxstylestrong{sd} along the reference axis \sphinxstylestrong{ar} and the
other axis.  (\sphinxstylestrong{an} cross \sphinxstylestrong{ar}).
If the source is at a finite distance then x and y are displacements
in mm (or whatever distance unit is used) of the position \sphinxstylestrong{sp} along
the reference axis \sphinxstylestrong{ar} and the other axis (\sphinxstylestrong{an} cross \sphinxstylestrong{ar}).

\sphinxstylestrong{Detector}

The detector consists of an annular or rectangular aperture on a planar
or spherical surface. More than one detector can be specified for an instrument.
Each detector defined will
occupy a given position within the sequence of optical elements specified.


\section{Monte Carlo and Random Numbers}
\label{\detokenize{xsrt_random:monte-carlo-and-random-numbers}}\label{\detokenize{xsrt_random::doc}}
The starting positions of rays, X-ray scattering angles from surface roughness and
some surface figure errors/deformations are generated using random numbers.
The sequence of random numbers used will be different each run unless the
random number seed is set using function rseed(). If the same seed value is set
before calling the function trace() exactly the same random sequence will be
generated for the ray tracing and the results will be identical.


\section{Deformations}
\label{\detokenize{xsrt_deformations:deformations}}\label{\detokenize{xsrt_deformations::doc}}
Deformations of surfaces can be specified using matricies which either span
a grid of points in the local coordinate system of the surface or
are indexed using integer labels for sectors or areas on a surface.
A set of deformations pertaining to a single surface or group of
related surfaces are given a deformation index (integer 1,2,3…).
The positions of the deformation grid points in local coordinates are
specified by two 1-dimensional arrays.

Alternatively deformations can be specified using functions with parameters set
separately for local x and y coordinates.

A surface deformation is applied along the normal to the surface. The
deformation value is interpolated from the 2-d grid of points.

Radial deformations for annula apertures are specified by a vector, sampling
in 1-d in azimuth, and the deformation is applied as a perturbation in the radial
direction.

The function xsrt.deform() is used to set up the type and dimensionality of a
particular deformation and must be the first call. The component matricies or
function parameters are then set using calls to xsrt.defmat() or
xsrt.defparxy().

A deformation applied to the source() spreads the point source into a pixel
array. See \sphinxstylestrong{Source of Rays}.


\section{Surface Quality, Reflectivity and Scattering}
\label{\detokenize{xsrt_surfaces:surface-quality-reflectivity-and-scattering}}\label{\detokenize{xsrt_surfaces::doc}}
Several surface qualities can be set up for the simulation of a given
instrument. Each is referenced using a surface quality index
(integer 1,2,3…). The type of surface can be reflecting (with reflectivity
specified using Fresnel’s equations or a lookup table), refracting
or diffracting. The roughness of the surface can also be specified
using a power law distribution.

The X-ray optical constants \sphinxstylestrong{alpha} and \sphinxstylestrong{gamma} can be calculated for
a material of specified composition using the function xscat.xopt().
Within the ray tracing the reflectivity is calculated using these
constants using the same code as in function xscat.xfresnel().

The reflectivity as a function of incidence angle in other energy bands can be
calculated from the real and imaginary part of the refractive index using
the function fresnel().

Stops which are intended to block radiation have a surface quality index
set to 0. When rays hit such surfaces they are terminated (absorbed).
Detectors have surface quality index -1. If a ray hits such a surface
it is terminated (detected).
The source aperture surface has quality index -2.
The quality indices of the source, stops and detectors are set automatically.
As ray tracing proceeds rays are stored for further analysis. Each position
along a ray where an intersection with a surface element occured is
labelled with the quality index of the surface.

For a grating the surface type is it=4.
In this case the ruling direction is specified by
the surface element axis and dhub controls the geometry. dhub \textless{} 1 in-plane
in which the dhub specifies the d-spacing gradient across the ruling
and dhub \textgreater{} 1 off-plane where the d-spacing gradient along the ruling is
determined from the distance to the hub.


\section{X-ray Telescopes, Lens and Prism}
\label{\detokenize{xsrt_telescopes:x-ray-telescopes-lens-and-prism}}\label{\detokenize{xsrt_telescopes::doc}}
\sphinxstylestrong{Wolter Telescopes}

A nest of Wolter I shells is set up using the function w1nest() and
a conical approximation to the same by c1nest(). A Wolter II telescope
is set up using the function wolter2().
A Wolter I telescope manufactured as an array of Silicon Pore Optics
(like Athena) is set up using the function spoarr().

\sphinxstylestrong{Lobster Eye and Kirkpatrick-Baez Telescopes}

A lobster eye telscope is set up using the function sqmpoarr().

A silicon pore Kirkpatrick-Baez stack is defined using the function
kbs().

A Schmidt configuration lobster eye telescope is set up using the
function sle().

\sphinxstylestrong{Apertures, stops, baffles and support structure}

The function aperture() sets up stops with various geometries, single
annulus, nested annuli, rectangular holes/blocks, rectangular grid,
polar sectors, paralleogram. Cylindrical baffles in front of behind
circular apertures are set up using the function baffle(). Spider
support structures commomly used in Wolter systems are set up using
the function spider().

\sphinxstylestrong{Lens and Prism}

Refracting lens and prism are defined using functions lens() and prism().


\section{Ray Tracing and Saving Rays}
\label{\detokenize{xsrt_tracing:ray-tracing-and-saving-rays}}\label{\detokenize{xsrt_tracing::doc}}
Once the source, detector and other elements have been defined rays can be
traced through the instrument using the function trace(). The form of the
output is controlled by the parameter \sphinxstylestrong{iopt}.
\begin{itemize}
\item {} 
-2 save traced.dat and detected.dat files

\item {} 
-1 save detected.dat

\item {} 
0 don’t save files or adjust focus

\item {} 
1 adjust focus and save detected.dat

\item {} 
2 adjust focus and save detected.dat and traced.dat

\item {} 
Only rays with \sphinxstylestrong{iopt} reflections are used in adjustment

\end{itemize}

The files traced.dat and detected.dat are ASCII tabulations.

When \sphinxstylestrong{iopt} is +ve then the detector position which gives the best focus is
determined. Only rays which have \sphinxstylestrong{iopt} reflections and impact the detector
within a radius \sphinxstylestrong{riris} of the centre of the detector are included in the
analysis. The detector is shifted along the normal direction to find
the axial position of minimum rms radial spread. The results of this
analysis are returned as:
\begin{itemize}
\item {} 
\sphinxstylestrong{area}    detected area within RIRIS

\item {} 
\sphinxstylestrong{dshft}   axial shift to optimum focus (0.0 if IOPT\textless{}=0)

\item {} 
\sphinxstylestrong{ybar}    y centroid of detected distribution

\item {} 
\sphinxstylestrong{zbar}    z centroid of detected distribution

\item {} 
\sphinxstylestrong{rms}     rms radius of detected distribution

\end{itemize}

The file traced.dat contains the paths of all the rays. It can be very large
so should not be saved unless required for detailed analysis.
\begin{itemize}
\item {} 
\sphinxstylestrong{RXP,RYP,RZP}  positions of points along each ray

\item {} 
\sphinxstylestrong{AREA} aperture area associated with ray

\item {} 
\sphinxstylestrong{IQU}  quality index -2 at source, 1 reflected, 0 absorbed, -1 detected

\end{itemize}

Note: in the tabulation the beginning of each ray is identified using \sphinxstylestrong{IQU=-2}
and the end using \sphinxstylestrong{IQU=0} absorbed or \sphinxstylestrong{IQU=-1} detected. Using these data
you can plot the paths of all the rays.

The file detected.dat contains information about the detected rays.
\begin{itemize}
\item {} 
\sphinxstylestrong{XD,YD,ZD}  the detected position for each ray

\item {} 
\sphinxstylestrong{XC,YC,ZC}  the direction cosines for each ray

\item {} 
\sphinxstylestrong{XR,YR,ZR}  the position of the last interaction before detection

\item {} 
\sphinxstylestrong{YDET,ZDET} the local detected position on detector

\item {} 
\sphinxstylestrong{AREA}  the aperture area associated with the ray

\item {} 
\sphinxstylestrong{IREF} the number of reflections suffered by the ray

\end{itemize}

The position \sphinxstylestrong{XR,YR,ZR} is used to indicate where the ray came from.

The following snippets of code show how an image of the detected rays can be
generated in Python or R.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{images}
\PYG{k+kn}{import} \PYG{n+nn}{xsrt}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{c+c1}{\PYGZsh{} half width of image mm}
\PYG{n}{hwid}\PYG{o}{=}\PYG{l+m+mf}{5.0}
\PYG{c+c1}{\PYGZsh{} trace all the rays}
\PYG{n}{results}\PYG{o}{=}\PYG{n}{xsrt}\PYG{o}{.}\PYG{n}{trace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{rdet}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create an image of the detected area}
\PYG{n}{XD}\PYG{p}{,}\PYG{n}{YD}\PYG{p}{,}\PYG{n}{ZD}\PYG{p}{,}\PYG{n}{XC}\PYG{p}{,}\PYG{n}{YC}\PYG{p}{,}\PYG{n}{ZC}\PYG{p}{,}\PYG{n}{XR}\PYG{p}{,}\PYG{n}{YR}\PYG{p}{,}\PYG{n}{ZR}\PYG{p}{,}\PYG{n}{YDET}\PYG{p}{,}\PYG{n}{ZDET}\PYG{p}{,}\PYG{n}{AREA}\PYG{p}{,}\PYG{n}{IREF}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{loadtxt}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{detected.dat}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{skiprows}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{unpack}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{arr}\PYG{o}{=}\PYG{n}{images}\PYG{o}{.}\PYG{n}{binxy}\PYG{p}{(}\PYG{n}{YDET}\PYG{p}{,}\PYG{n}{ZDET}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{AREA}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{hwid}\PYG{p}{,}\PYG{n}{nx}\PYG{p}{,}\PYG{n}{ny}\PYG{p}{)}
\end{sphinxVerbatim}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} half width of image mm}
hwid\PYG{o}{\PYGZlt{}\PYGZhy{}} \PYG{l+m}{5.0}
\PYG{c+c1}{\PYGZsh{} trace all the rays}
results\PYG{o}{\PYGZlt{}\PYGZhy{}} qrt\PYGZus{}trace\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{,}rdet\PYG{p}{,}\PYG{l+m}{\PYGZhy{}2}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Create an image of the detected area}
detpos\PYG{o}{\PYGZlt{}\PYGZhy{}}read.table\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{detected.dat\PYGZdq{}}\PYG{p}{,}header\PYG{o}{=}\PYG{k+kc}{TRUE}\PYG{p}{)}
aim\PYG{o}{\PYGZlt{}\PYGZhy{}}qri\PYGZus{}binxy\PYG{p}{(}detpos\PYG{o}{\PYGZdl{}}YDET\PYG{p}{,}detpos\PYG{o}{\PYGZdl{}}ZDET\PYG{p}{,}\PYG{l+m}{0}\PYG{p}{,}detpos\PYG{o}{\PYGZdl{}}AREA\PYG{p}{,}\PYG{o}{\PYGZhy{}}hwid\PYG{p}{,}hwid\PYG{p}{,}nx\PYG{p}{,}\PYG{o}{\PYGZhy{}}hwid\PYG{p}{,}hwid\PYG{p}{,}ny\PYG{p}{)}
\end{sphinxVerbatim}

In Python \sphinxstylestrong{arr} is an image array. In R \sphinxstylestrong{aim} is an image object which
contains the image array \sphinxstylestrong{aim\$data\_array}.
In both cases the function images.binxy() is used to bin up the aperture area
associated with each ray into an image (2-d histogram). The effective area
is found by summing up areas of the image.


\section{xsrt.functions}
\label{\detokenize{xsrt_functions:xsrt-functions}}\label{\detokenize{xsrt_functions::doc}}
\sphinxstylestrong{Utility functions}
\begin{itemize}
\item {} 
rotate() Rotate surface element

\item {} 
shift() Shift position of surface element

\item {} 
rseed() Set random number seed

\item {} 
srtlist() List all current xsrt parameters

\item {} 
setreset() Reset Fortran common blocks to inital condition

\end{itemize}

\sphinxstylestrong{Apertures, baffles and support structure}
\begin{itemize}
\item {} 
aperture() Set up an aperture stop

\item {} 
baffle() Set up a cylindrical baffle

\item {} 
spider() Set up a support spider

\end{itemize}

\sphinxstylestrong{Wolter systems}
\begin{itemize}
\item {} 
w1nest() Set up a Wolter Type I nest

\item {} 
c1nest() Set up conical approximation to a Wolter type I nest

\item {} 
sipore() Set up Silicon Pore Optics

\item {} 
spoarr() Set up Silicon Pore Optics array

\item {} 
wolter2() Set up Wolter Type II surfaces

\end{itemize}

\sphinxstylestrong{Square pore and Kirkpatrick-Baez systems}
\begin{itemize}
\item {} 
sqpore() Set up slumped square pore MPOs

\item {} 
sqmpoarr() Set up an array of square pore MPOs

\item {} 
kbs() Set up a Silicon Kirkpatrick-Baez stack array

\item {} 
sle() Set up a Schmidt lobster eye stack

\end{itemize}

\sphinxstylestrong{Common optical elements}
\begin{itemize}
\item {} 
lens() Set up a lens

\item {} 
prism() Set up a prism

\item {} 
mirror() Set up a plane mirror

\item {} 
elips() Set up elliptical grazing indidence mirror

\item {} 
moa() Set up a cylindrical Micro Optic Array

\item {} 
opgrat() Set up a single off-plane grating

\end{itemize}

\sphinxstylestrong{Surface quality and deformations}
\begin{itemize}
\item {} 
surface() Set surface quality parameters

\item {} 
fresnel() Calculate reflectivity using Fresnel’s equations

\item {} 
deform() Set up surface deformation dimensions

\item {} 
defmat() Load deformation matrix

\item {} 
defparxy() Set up deformation defined by parameters in x and y axes

\end{itemize}

\sphinxstylestrong{Source of rays, tracing rays, detecting rays}
\begin{itemize}
\item {} 
source() Set up source of rays

\item {} 
trace() Perform ray tracing

\item {} 
detector() Set up detector

\end{itemize}

\sphinxstylestrong{Tracing charged particles through magnetic fields}
\begin{itemize}
\item {} 
bfield() Calculation of magnetic field for array of dipoles

\item {} 
eltmxt() Trace electrons through SVOM MXT telescope with magnetic diverter

\item {} 
prtathena() Trace proton through Athena telescope with magnetic diverter

\end{itemize}
\phantomsection\label{\detokenize{xsrt_functions:module-xsrt}}\index{xsrt (module)}\index{aperture() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.aperture}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{aperture}}}{\emph{idd}, \emph{idf}, \emph{ap}, \emph{an}, \emph{ar}, \emph{alim}, \emph{nsurf}}{}
Set up an aperture stop
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} aperture type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ap}} \textendash{} position of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{an}} \textendash{} normal to aperture plane

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} reference axis in aperture plane

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alim}} \textendash{} limit values (depend on id see above)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nsurf}} \textendash{} number of subsequent surfaces per aperture (id=2)

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{\sphinxstylestrong{id} values:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] 1 Single annulus, radial limits (aref,rmin,rmax,0,0,0)
\item[] 2 Nested annuli, radial limits  (aref,rmin1,rmax1,rmin2,0,0)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] aref is an axial reference position used for deformation
\end{DUlineblock}
\item[] 3 Hole Cartesian limits (xmin,ymin,xmax,ymax,0,0)
\item[] 4 Block Cartesian limits (xmin,ymin,xmax,ymax,0,0)
\item[] 5 Cartesian grid limits (pitchx pitchy ribx riby,0,0)
\item[] 6 Radial/azimuthal sector limits (rmin,rmax,amin,amax,0,0)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] amin and amax in radians range 0-2pi
\end{DUlineblock}
\item[] 7 Parallelogram limits (xmin,ymin,xmax,ymax,dx,0)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] where dx is the shear in X over the distance ymax-ymin
\end{DUlineblock}
\item[] 8 Aperture for MCO test station limits (hsize dols,0,0,0,0)
\end{DUlineblock}

\end{description}

The parameter \sphinxstylestrong{nsurf} is used for radially nested apertures so that
the code knows how many surface elements to skip if a ray penitrates
a particular annulus.

If the limits are radial the deformation is defined as a vector (1-d
sampless in azimuth) and is applied in the radial direction.

If the limits are cartesian, radial/azimuthal or parallelogram
the deformation is defined over a matrix (2-d) and is applied in the
direction of the normal.

No deformation is used for \sphinxstylestrong{id=8}.

\end{fulllineitems}

\index{baffle() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.baffle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{baffle}}}{\emph{xmin}, \emph{xmax}, \emph{rad}, \emph{ax}, \emph{ar}, \emph{rp}, \emph{iq}}{}
Set up a cylindrical baffle
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xmin}} \textendash{} axial position of base

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xmax}} \textendash{} axial position of top

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rad}} \textendash{} radius of cylinder

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} \textendash{} axis direction

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} reference direction perpendicular to axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rp}} \textendash{} position of vertex

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\end{itemize}

\end{description}\end{quote}

The axial positions of the base and top, \sphinxstylestrong{xmin} and \sphinxstylestrong{xmax}
are local coordinates wrt \sphinxstylestrong{ap} along the \sphinxstylestrong{ax} direction.

\end{fulllineitems}

\index{bfield() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.bfield}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{bfield}}}{\emph{dm}, \emph{pdx}, \emph{pdy}, \emph{pdz}, \emph{ddx}, \emph{ddy}, \emph{ddz}, \emph{px}, \emph{py}, \emph{pz}}{}
Calculation of magnetic field for array of dipoles
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dm}} \textendash{} dipole moments (Gauss cm3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdx}} \textendash{} x positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdy}} \textendash{} y positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdz}} \textendash{} z positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddx}} \textendash{} x direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddy}} \textendash{} y direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddz}} \textendash{} z direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{px}} \textendash{} x positions for calculation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{py}} \textendash{} y positions for calculation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pz}} \textendash{} z positions for calculation

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{bf}     magnitude of B-field Gauss
\item[] \sphinxstylestrong{dx}     direction cosines of B-field in x direction
\item[] \sphinxstylestrong{dy}     direction cosines of B-field in y direction
\item[] \sphinxstylestrong{dz}     direction cosines of B-field in z direction
\item[] \sphinxstylestrong{rmin}   minimum distance from dipoles
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{c1nest() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.c1nest}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{c1nest}}}{\emph{ax}, \emph{ar}, \emph{ff}, \emph{iq}, \emph{ib}, \emph{idf}, \emph{pl}, \emph{ph}, \emph{hl}, \emph{hh}, \emph{rpl}, \emph{rph}, \emph{rhl}, \emph{rhh}, \emph{tin}, \emph{tj}, \emph{tout}}{}
Set up conical approximation to a Wolter type I nest
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} \textendash{} optical axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} reference axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ff}} \textendash{} position of focus

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} array of low axial position of parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ph}} \textendash{} array of high axial position of parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hl}} \textendash{} array of low axial position of hyperbola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hh}} \textendash{} array of high axial position of hyperbola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rp}} \textendash{} array of radii parabola near join

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rp}} \textendash{} array of radii parabola at input aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rhl}} \textendash{} array of radii hyperbola at exit aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rjh}} \textendash{} array of radii hyperbola near join

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tin}} \textendash{} array of thicknesses of shells at input aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tj}} \textendash{} array of thicknesses of shells at join plane (or near join)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tout}} \textendash{} array of thicknesses of shells at the output aperture

\end{itemize}

\end{description}\end{quote}

The innermost shell is a dummy and provides an inner stop for the nest
\begin{description}
\item[{Deformation:}] \leavevmode
A deformation sub-matrix is required for each shell (not
including the innermost shell)
Each matrix covers a grid of points along the axis in mm and azimuth
in radians. The axial range covers both the 1st and 2nd reflection
surfaces.
The values in the matrices are radial displacments mm at the grid
points.

\end{description}

\end{fulllineitems}

\index{defmat() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.defmat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{defmat}}}{\emph{idd}, \emph{im}, \emph{xsam}, \emph{ysam}, \emph{zdef}}{}
Load deformation matrix
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} sub-matrix index (runs from 1-N)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xsam}} \textendash{} x values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ysam}} \textendash{} y values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zdef}} \textendash{} deformation matrix

\end{itemize}

\end{description}\end{quote}

Note for deformation of a surface of revolution X is axial direction and
Y is azimuth.

Used when \sphinxstylestrong{it=1} in deform().

\end{fulllineitems}

\index{deform() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.deform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{deform}}}{\emph{idd}, \emph{it}, \emph{nm}, \emph{nx}, \emph{ny}}{}
Set up surface deformation dimensions
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{it}} \textendash{} deformation type (1 matrix, 2 sin() in x and/or y)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nm}} \textendash{} number of sub-matrices

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nx}} \textendash{} number of x samples

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ny}} \textendash{} number of y samples

\end{itemize}

\end{description}\end{quote}

Note when \sphinxstylestrong{it=2} the sin() function requires 3 parameters, amplitude (\sphinxstylestrong{amp}),
wavelength (\sphinxstylestrong{lam}) and phase (\sphinxstylestrong{phi}) all in mm (or the same units)
\sphinxstylestrong{defx=amp.sin(2.pi.(x-phi)/lam)}

If \sphinxstylestrong{it} -ve then uses \sphinxstylestrong{abs(it)} but expects a 2nd deformation to be
defined which will be added to the current deformation.

\end{fulllineitems}

\index{defparxy() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.defparxy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{defparxy}}}{\emph{idd}, \emph{im}, \emph{xpar}, \emph{ypar}}{}
Sets parameters of deformation defined by parameters in x and y axes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idd}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{im}} \textendash{} sub-surface index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xpar}} \textendash{} parameters of deformations in x axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ypar}} \textendash{} parameters of deformations in y axis

\end{itemize}

\end{description}\end{quote}

Empty field {[}{]} can be used as xpar or ypar if there are no deformations
in the corresponding axis.

Use this routine to set parameteric deformations, e.g.
when \sphinxstylestrong{it=2} in deform() the sin() function requires 3 parameters,
amplitude (\sphinxstylestrong{amp}), wavelength (\sphinxstylestrong{lam}) and phase (\sphinxstylestrong{phi}) all in mm
(or the same units) \sphinxstylestrong{defx=amp.sin(2.pi.(x-phi)/lam)}

\end{fulllineitems}

\index{detector() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.detector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{detector}}}{\emph{idd}, \emph{dpos}, \emph{dnml}, \emph{drfx}, \emph{dlim}, \emph{radet}}{}
Set up detector
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} detector type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dpos}} \textendash{} detector position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dnml}} \textendash{} detector normal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{drfx}} \textendash{} detector reference axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dlim}} \textendash{} detector limits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{radet}} \textendash{} radius of curvature of spherical detector

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{\sphinxstylestrong{id} values:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] 1 planar detector, radial limits
\item[] 2 planar detector, cartesian limits
\item[] 3 spherical detector, radial limits
\item[] 4 spherical detector, cartesian limits
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{elips() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.elips}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{elips}}}{\emph{org}, \emph{axs}, \emph{cen}, \emph{xmin}, \emph{xmax}, \emph{amin}, \emph{amax}, \emph{smb}, \emph{rab}, \emph{ide}, \emph{iq}}{}
Set up elliptical grazing indidence mirror
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{org}} \textendash{} local origin on surface of ellipse

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{axs}} \textendash{} reference axis in aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cen}} \textendash{} focus of ellipse

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xmin}} \textendash{} minimum axial position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xmax}} \textendash{} maximum axial position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amin}} \textendash{} minimum azimuth radians

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{amax}} \textendash{} maximum azimuth radians

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{smb}} \textendash{} conic coefficient

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rab}} \textendash{} conic coefficient
conic equation of form r**2=rab**2.x**2+smb**2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ide}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} reflecting surface quality

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{eltmxt() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.eltmxt}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{eltmxt}}}{\emph{dm}, \emph{pdx}, \emph{pdy}, \emph{pdz}, \emph{ddx}, \emph{ddy}, \emph{ddz}, \emph{ekv}, \emph{tsig}, \emph{xaper}, \emph{xdiv}, \emph{apy}, \emph{apz}, \emph{apsiz}, \emph{wdiv}, \emph{ddiv}, \emph{sdet}, \emph{maxst}}{}
Trace electrons through SVOM MXT telescope with magnetic diverter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dm}} \textendash{} dipole moments (Gauss cm3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdx}} \textendash{} x positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdy}} \textendash{} y positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdz}} \textendash{} z positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddx}} \textendash{} x direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddy}} \textendash{} y direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddz}} \textendash{} z direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekv}} \textendash{} proton energy keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tsig}} \textendash{} rms width of beam degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xaper}} \textendash{} x position of mirror aperture cm (focal length)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xdiv}} \textendash{} x position of diverter input aperture cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apy}} \textendash{} y centre of apertures cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apz}} \textendash{} z centre of apertures cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apsiz}} \textendash{} aperture size (3.8) cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wdiv}} \textendash{} extra width of diverter apertures (0.2) cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddiv}} \textendash{} axial depth of diverter cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sdet}} \textendash{} size of detector cm (axial position XDET=0.0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maxst}} \textendash{} maximum number of steps along path

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of the following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{npath}  number of points along path
\item[] \sphinxstylestrong{iqual}  type of path
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 0 hits active detector
\item[] 1 too close to dipole
\item[] 2 hits telescope tube
\item[] 3 hits mirror aperture
\item[] 4 hits diverter
\item[] 5 hits focal plane beyond detector
\item[] 6 hit maximum number of steps
\end{DUlineblock}
\item[] \sphinxstylestrong{xp}     x positions along path cm
\item[] \sphinxstylestrong{yp}     y positions along path cm
\item[] \sphinxstylestrong{zp}     z positions along path cm
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{fresnel() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.fresnel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{fresnel}}}{\emph{nreal}, \emph{kimag}, \emph{angs}}{}
Calculate reflectivity using Fresnel’s equations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nreal}} \textendash{} real part of refractive index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{kimag}} \textendash{} imaginary part of refractive index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{angs}} \textendash{} array of incidence angles (degrees range 0-90)

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{rs}          sigma reflectivity
\item[] \sphinxstylestrong{rp}          pi reflectivity
\item[] \sphinxstylestrong{runp}        unpolarized reflectivity
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\begin{DUlineblock}{0em}
\item[] Reference “Handbook of Optical Constants of Solids” Ed. Edward D.Palik
\item[] Academic Press 1985, page 70
\item[] If angs(I) out of range 0-90 degrees returns zero reflectivities
\end{DUlineblock}

\end{fulllineitems}

\index{init() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.init}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{init}}}{}{}
Initialisation of Fortran common blocks

\end{fulllineitems}

\index{kbs() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.kbs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{kbs}}}{\emph{pcen}, \emph{pnor}, \emph{raxi}, \emph{ipack}, \emph{rmin}, \emph{rmax}, \emph{flen}, \emph{csize}, \emph{pitch}, \emph{wall}, \emph{plmin}, \emph{plmax}, \emph{idf}, \emph{iq}}{}
Set up a Silicon Kirkpatrick-Baez stack array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} centre of telescope aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pnor}} \textendash{} normal to aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{razi}} \textendash{} reference axis at centre of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ipack}} \textendash{} packing 0 single module, 1 sunflower, 2 cartesian, 3 wide
field cartesian

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rmin}} \textendash{} minimum radius for aperture of constellation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rmax}} \textendash{} maximum radius for aperture of constellation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flen}} \textendash{} focal length (-ve for 2nd stack)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csize}} \textendash{} size of each module in constellation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pitch}} \textendash{} pitch of K-B slots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wall}} \textendash{} wall thickness of K-B slots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plmin}} \textendash{} minimum axial length of K-B slots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plmax}} \textendash{} maximum axial length of K-B slots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{rc}        radius of each module
\item[] \sphinxstylestrong{pc}        azimuth of each module
\item[] \sphinxstylestrong{tc}        rotation of each module
\item[] \sphinxstylestrong{ac}        axial length of each module
\item[] \sphinxstylestrong{nset}      number of module coordinates returned
\end{DUlineblock}


\end{description}\end{quote}
\begin{description}
\item[{Deformation:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] matrix is (5,nmod) specifying 5 deformations per module.
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1 displacement of module vertex in \sphinxstylestrong{razi} mm
\item[] 2 displacement of module vertex in \sphinxstylestrong{pnor X razi} mm
\item[] 3 displaement of module vertex in \sphinxstylestrong{pnor} mm
\item[] 4 rms Gaussian in-plane figure errors radians
\item[] 5 rms Gaussian out-of-plane figure errors radians
\end{DUlineblock}
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{lens() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.lens}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{lens}}}{\emph{idd}, \emph{idf}, \emph{iq}, \emph{anml}, \emph{arfx}, \emph{apos}, \emph{rap}, \emph{r1}, \emph{r2}, \emph{refind}, \emph{thickq}}{}
Set up a lens
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} lens type 1 spherical, 2 cylindrical

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{anml}} \textendash{} surface normal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{arfx}} \textendash{} surface reference axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apos}} \textendash{} surface reference position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rap}} \textendash{} radius of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{r1}}\sphinxstyleliteralstrong{\sphinxupquote{,}}\sphinxstyleliteralstrong{\sphinxupquote{r2}} \textendash{} radii of curvature of lens surfaces

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refind}} \textendash{} refractive index of lens material (or n2/n1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{thick}} \textendash{} lens thickness

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Surface quality:}] \leavevmode
This function sets up 2 surface qualities \sphinxstylestrong{iq} and \sphinxstylestrong{iq+1} to
represent the entrance and exit surfaces.

\end{description}

\end{fulllineitems}

\index{mirror() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.mirror}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{mirror}}}{\emph{idd}, \emph{idf}, \emph{iq}, \emph{anml}, \emph{arfx}, \emph{apos}, \emph{alim}, \emph{nsurf}}{}
Set up a plane mirror
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idd}} \textendash{} aperture type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{anml}} \textendash{} surface normal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{arfx}} \textendash{} surface reference axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apos}} \textendash{} surface reference position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alim}} \textendash{} limits array (see aperture() )

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nsurf}} \textendash{} number of subsequent surfaces ID=2

\end{itemize}

\end{description}\end{quote}

The aperture limits of the mirror are specified in the same way as
for a top. See function aperture().

\end{fulllineitems}

\index{moa() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.moa}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{moa}}}{\emph{pcen}, \emph{pno}, \emph{rax}, \emph{rcur}, \emph{xyap}, \emph{pitch}, \emph{wall}, \emph{plen}, \emph{idf}, \emph{iq}}{}
Set up a cylindrical Micro Optic Array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} centre of MOA

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pno}} \textendash{} normal at centre of MOA

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rax}} \textendash{} cylindrical axis of MOA

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rcur}} \textendash{} radius of curvature of cylinder

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xyap}} \textendash{} half width of MOA aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pitchnput}} \textendash{} pitch of slots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wall}} \textendash{} wall thickness between slots

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plen}} \textendash{} depth of slots (thickness MOA)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{opgrat() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.opgrat}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{opgrat}}}{\emph{idd}, \emph{defi}, \emph{iq}, \emph{al}, \emph{fpos}, \emph{zpos}, \emph{gpos}, \emph{alim}}{}
Set up a single off-plane grating
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} 1 radial, 2 nested rad., 4 cart., 6 slats

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{defi}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{al}} \textendash{} azimuthal exit angle of zeroth order on cone degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fpos}} \textendash{} position of primary focus (not reflected)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zpos}} \textendash{} position of zeroth order focus (reflected)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gpos}} \textendash{} position of centre of grating

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alim}} \textendash{} limits on surface

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{adir}     grating normal
\item[] \sphinxstylestrong{rdir}     grating ruling
\item[] \sphinxstylestrong{dpos}     grating hub
\item[] \sphinxstylestrong{graz}     grating grazing angle radians
\item[] \sphinxstylestrong{gam}      grating cone angle radians
\item[] \sphinxstylestrong{dhub}     grating hub distance
\end{DUlineblock}


\end{description}\end{quote}

The grating parameters \sphinxstylestrong{gpitch}, \sphinxstylestrong{dhub} and \sphinxstylestrong{order} and the
reflectivity as a function of incidence angle are set by
the surface quality (index \sphinxstylestrong{iq}).

\end{fulllineitems}

\index{prism() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.prism}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{prism}}}{\emph{idd}, \emph{idf}, \emph{iq}, \emph{anml}, \emph{arfx}, \emph{apos}, \emph{rap}, \emph{d1}, \emph{d2}, \emph{refind}, \emph{thick}}{}
Set up a prism
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} 1 small angle, 2 right-angle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{anml}} \textendash{} entrance surface normal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{arfx}} \textendash{} reference axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apos}} \textendash{} reference position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rap}} \textendash{} aperture radius

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{d1}} \textendash{} small angle radians on entry side (if ID=1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{d2}} \textendash{} small angle radians on exit side (if ID=1)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refind}} \textendash{} refractive index of material or n2/n1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{thick}} \textendash{} thickness

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Surface quality:}] \leavevmode
This function sets up 2 surface qualities \sphinxstylestrong{iq} and \sphinxstylestrong{iq+1} to
represent the entrance and exit surfaces.

\end{description}

\end{fulllineitems}

\index{prtathena() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.prtathena}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{prtathena}}}{\emph{dm}, \emph{pdx}, \emph{pdy}, \emph{pdz}, \emph{ddx}, \emph{ddy}, \emph{ddz}, \emph{ekv}, \emph{tsig}, \emph{xaper}, \emph{xdiv}, \emph{rrings}, \emph{trings}, \emph{drings}, \emph{rdet}, \emph{maxst}}{}
Trace proton through Athena telescope with magnetic diverter
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dm}} \textendash{} dipole moments (Gauss cm3)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdx}} \textendash{} x positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdy}} \textendash{} y positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdz}} \textendash{} z positions of dipoles (cm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddx}} \textendash{} x direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddy}} \textendash{} y direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ddz}} \textendash{} z direction cosines of dipole moments

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ekv}} \textendash{} proton energy keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tsig}} \textendash{} rms width of beam degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xaper}} \textendash{} x position of mirror aperture cm (focal length)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xdiv}} \textendash{} x position of diverter input aperture cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nrings}} \textendash{} number of rings in diverter

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rrings}} \textendash{} radius of rings in diverter cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{trings}} \textendash{} radial thickness of rings in diverter cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{drings}} \textendash{} axial depth of rings in diverter cm

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rdet}} \textendash{} radius of detector cm (axial position XDET=0.0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{maxst}} \textendash{} maximum number of steps along path

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{npath}  number of points along path
\item[] \sphinxstylestrong{iqual}  type of path
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 0 hits active detector
\item[] 1 too close to dipole
\item[] 2 hits telescope tube
\item[] 3 hits mirror aperture
\item[] 4 hits diverter
\item[] 5 hits focal plane beyond detector
\item[] 6 hit maximum number of steps
\end{DUlineblock}
\item[] \sphinxstylestrong{xp}     x positions along path cm
\item[] \sphinxstylestrong{yp}     y positions along path cm
\item[] \sphinxstylestrong{zp}     z positions along path cm
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.reset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{reset}}}{}{}
Reseting of Fortran common blocks to initial condition

\end{fulllineitems}

\index{rotate() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.rotate}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{rotate}}}{\emph{iss}, \emph{pl}, \emph{ax}, \emph{angle}}{}
Rotate surface element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iss}} \textendash{} surface element index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} position of rotation centre (x,y,z)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} \textendash{} rotation axis (ax,ay,az)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{angle}} \textendash{} rotation angle degrees

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{rseed() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.rseed}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{rseed}}}{\emph{iseed}}{}
Set random number seed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{iseed}} \textendash{} integer seed

\end{description}\end{quote}

\end{fulllineitems}

\index{shift() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.shift}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{shift}}}{\emph{iss}, \emph{pl}}{}
Shift position of surface element
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iss}} \textendash{} surface element index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} 3 vector shift (dx,dx,dz)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{sipore() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.sipore}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{sipore}}}{\emph{pcen}, \emph{pnorm}, \emph{raxis}, \emph{flen}, \emph{rpitch}, \emph{apitch}, \emph{wall}, \emph{rm}, \emph{pm}, \emph{tm}, \emph{wm}, \emph{hm}, \emph{am}, \emph{cm}, \emph{gm}, \emph{wfr}, \emph{a2j}, \emph{idf}, \emph{iq}}{}
Set up Silicon Pore Optics
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} position of centre of aperture (above join plane)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rnorm}} \textendash{} normal at centre of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{raxis}} \textendash{} reference axis at centre of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flen}} \textendash{} focal length

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rpitch}} \textendash{} pore radial pitch

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apitch}} \textendash{} pore azimuthal pitch

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wall}} \textendash{} wall thickness

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rm}} \textendash{} array of module radii

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pm}} \textendash{} array of module azimuths (radians)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tm}} \textendash{} array of module rotations (radians normally 0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wm}} \textendash{} array of module widths (radial mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hm}} \textendash{} array of module heights (azimuthal mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{am}} \textendash{} array of module lengths (axial pore length mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cm}} \textendash{} array of module curvature signatures
0 conical, 1 Wolter, 2 curve-plane, 3 constant…

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gm}} \textendash{} array of module grazing angle ratios

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wrf}} \textendash{} module frame width (surrounding module aperture)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a2j}} \textendash{} aperture to join plane axial distance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} reflecting surface quality

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{sle() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.sle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{sle}}}{\emph{pcen}, \emph{pnor}, \emph{raxi}, \emph{flen}, \emph{cwidth}, \emph{cheight}, \emph{pitch}, \emph{wall}, \emph{pl}, \emph{nmir}, \emph{idf}, \emph{iq}}{}
Defines Schmidt configuration lobster eye stack
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} centre of telescope aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pnor}} \textendash{} normal to aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{raxi}} \textendash{} reference axis at centre of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flen}} \textendash{} focal length (-ve for second stack) measured to front aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cwidth}} \textendash{} cell width = mirror width (its active part)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cheight}} \textendash{} cell height

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pitch}} \textendash{} pitch including mirrors thickness = pdd+wall

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wall}} \textendash{} mirror thickness

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} mirror axial length (depth)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\end{itemize}

\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{rc}        radius of each module
\item[] \sphinxstylestrong{pc}        azimuth of each module
\item[] \sphinxstylestrong{tc}        rotation of each module
\item[] \sphinxstylestrong{ac}        axial length of each module
\item[] \sphinxstylestrong{nset}      number of module coordinates returned
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{source() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.source}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{source}}}{\emph{it}, \emph{sd}, \emph{sp}, \emph{ap}, \emph{an}, \emph{ar}, \emph{al}, \emph{apry}, \emph{nr}, \emph{idef}}{}
Set up source
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{it}} \textendash{} source type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sd}} \textendash{} source direction cosines

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sp}} \textendash{} source position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ap}} \textendash{} aperture position

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{an}} \textendash{} aperture normal

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} aperture reference axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{al}} \textendash{} aperture limits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apry}} \textendash{} area per ray - if 0 then use NR

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nr}} \textendash{} number of rays

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idef}} \textendash{} deformation index

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{\sphinxstylestrong{it} values:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] 1 point source at infinity,        radial limits
\item[] 2 point source at infinity,        cartesian limits
\item[] 3 point source at finite distance, radial limits
\item[] 4 point source at finite distance, cartesian limits
\end{DUlineblock}

\item[{Deformation:}] \leavevmode
The deformation index is used to specify a pixel array which spreads
out a point source into an angular distribution. The deformation data are
set using two functions xsrt.deform() and xsrt.defmat().
If the source is at infinity the x and y sample arrays must be in radians
measured from the direction \sphinxstylestrong{sd} along the reference axis \sphinxstylestrong{ar} and the
other axis.  (\sphinxstylestrong{an} cross \sphinxstylestrong{ar}).
If the source is at a finite distance then x and y are displacements
in mm (or whatever distance unit is used) of the position \sphinxstylestrong{sp} along
the reference axis \sphinxstylestrong{ar} and the other axis (\sphinxstylestrong{an} cross \sphinxstylestrong{ar}).

\end{description}

\end{fulllineitems}

\index{spider() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.spider}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{spider}}}{\emph{cone}, \emph{apos}, \emph{anml}, \emph{arfx}, \emph{nsec}, \emph{cwid}, \emph{awid}}{}
Set up a support spider
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cone}} \textendash{} 90-half cone angle degrees (0.0 for plane)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apos}} \textendash{} axial position of vertex (centre)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{anml}} \textendash{} direction of normal to aperture (optic axis)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{afrx}} \textendash{} reference axis in aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nsec}} \textendash{} number of sectors (number of arms)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cwid}} \textendash{} constant arm width

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{awid}} \textendash{} angular arm width degrees

\end{itemize}

\end{description}\end{quote}

The surface figure of the spider aperture is a cone.
The width of the arms is given by \sphinxstylestrong{cwid+aw*R}
where \sphinxstylestrong{R} is the radial distance
from the axis of the cone and \sphinxstylestrong{aw} is \sphinxstylestrong{awid}
degrees converted into radians.

\end{fulllineitems}

\index{spoarr() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.spoarr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{spoarr}}}{\emph{pcen}, \emph{pnorm}, \emph{raxis}, \emph{flen}, \emph{a2j}, \emph{rm}, \emph{pm}, \emph{tm}, \emph{wm}, \emph{hm}, \emph{am}, \emph{cm}, \emph{gm}, \emph{rpitch}, \emph{wall}, \emph{apitch}, \emph{wfr}, \emph{siq}, \emph{idf}}{}
Set up Silicon Pore Optics Wolter I array
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} position of centre of aperture (above join plane)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rnorm}} \textendash{} normal at centre of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{raxis}} \textendash{} reference axis at centre of aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{flen}} \textendash{} focal length

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{a2j}} \textendash{} aperture to join plane axial distance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rm}} \textendash{} array of module radii

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pm}} \textendash{} array of module azimuths (radians)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tm}} \textendash{} array of module rotations (radians normally 0)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wm}} \textendash{} array of module widths (radial mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hm}} \textendash{} array of module heights (azimuthal mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{am}} \textendash{} array of module lengths (axial pore length mm)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cm}} \textendash{} array of module curvature signatures
0 conical, 1 Wolter, 2 curve-plane, 3 constant…

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gm}} \textendash{} array of module grazing angle ratios

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rpitch}} \textendash{} array of module pore radial pitch

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wall}} \textendash{} array of module wall thickness

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apitch}} \textendash{} array of module pore azimuthal pitch

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rwi}} \textendash{} array of module pore rib thickness

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wrf}} \textendash{} array of module frame widths (surrounding module aperture)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{siq}} \textendash{} array of surface quality indices

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Deformation:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] matrix is (6,nmod) specifying 6 deformations per module.
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1 displacement of module in direction \sphinxstylestrong{raxis} mm
\item[] 2 displacement of module in direction of \sphinxstylestrong{rnorm X raxis} mm
\item[] 3 error in focal length of module
\item[] 4 Gaussian rms in-plane figure error radians
\item[] 5 Gaussian rms out-of-plane figure error radians
\item[] 6 width mm along axial edges of module in which figure degrades
\end{DUlineblock}
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{sqmpoarr() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.sqmpoarr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{sqmpoarr}}}{\emph{pcen}, \emph{pnorm}, \emph{raxis}, \emph{rcur}, \emph{hwid}, \emph{idf}, \emph{ar}}{}
Set up an array of square pore MPOs
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} position of centre of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rnorm}} \textendash{} normal at centre of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{raxis}} \textendash{} reference axi at centre of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rcur}} \textendash{} radius of curvature of array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hwid}} \textendash{} half width of array aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index for array

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} array of additional parameters for each MPO in array

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Additional parameter array:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] there are 15 parameters for each MPO
\item[] XP     x position of each MPO
\item[] YP     y position of each MPO
\item[] TC     rotation angle of each MPO
\item[] WC     width of each MPO delx
\item[] HC     height of each MPO dely
\item[] AC     axial length of each MPO (thickness)
\item[] CU     radius of curvature of each MPO
\item[] MF     size of multifibres in MPO
\item[] PP     pitch of pores (pore size + wall thickness)
\item[] WA     wall thickness between pores
\item[] SQ     reflecting surface quality index for pores
\item[] BU     bias angle x radians
\item[] BV     bias angle y radians
\item[] BZ     spare parameter!
\item[] SP     spare parameter!
\end{DUlineblock}

\item[{Deformation:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] matrix (5,nmpo) specifying 5 deformations for each MPO
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] 1 scaling of intrinsic slumping distortion - 1.0 for model
\item[] 2 +ve amplitude thermoelastic pore axial pointing errors radians
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] -ve amplitude fixed pattern tilt errors radians
\end{DUlineblock}
\item[] 3 Gaussian rms pore rotation errors (about pore axis) radians
\item[] 4 pore shear error amplitude mm within multifibre structure
\item[] 5 +ve Gaussian rms pore tilt/figure error radians (x2.37=FWHM)
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] -ve Cauchy (Lorentzian) pore tilt/figure errors radians (x2=FWHM)
\item[] both applied independently in 2 tilt axes
\end{DUlineblock}
\end{DUlineblock}
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{sqpore() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.sqpore}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{sqpore}}}{\emph{pcen}, \emph{pnorm}, \emph{raxis}, \emph{rcur}, \emph{ipack}, \emph{rap}, \emph{pitch}, \emph{wall}, \emph{plen}, \emph{idf}, \emph{iq}, \emph{plmin}, \emph{plmax}, \emph{fibre}, \emph{ar}}{}
Set up slumped square pore MPO
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pcen}} \textendash{} position of centre of plate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rnorm}} \textendash{} normal at centre of plate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{raxis}} \textendash{} reference axi at centre of plate

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rcur}} \textendash{} radius of curvature

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ipack}} \textendash{} pore packing
1 cart, 2 rad, 3 waff, 4 octag, 5 rand, 6 MIXS, 7 NFL

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rap}} \textendash{} half width of plate aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pitch}} \textendash{} pitch of pores on a cartesian grid

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{wall}} \textendash{} pore wall thickness

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plen}} \textendash{} length of pores

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{idf}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plmin}} \textendash{} minimum pore length

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{plmax}} \textendash{} maximum pore length

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fibre}} \textendash{} size of fibre bundle in packing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} array of additional parameters specifying plate apertures

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Additional parameter array:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] used for ipack 6 or 7
\item[] RC,PC  radius and azimuth of each plate
\item[] TC     rotation angle of plate
\item[] WC     width of each plate x
\item[] HC     height of each plate y
\item[] AC     axial length of each plate
\item[] CC     spare
\item[] GC     spare
\end{DUlineblock}

\end{description}

\end{fulllineitems}

\index{srtlist() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.srtlist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{srtlist}}}{}{}
List all current xsrt parameters

\end{fulllineitems}

\index{srtreset() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.srtreset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{srtreset}}}{}{}
Reset Fortran common blocks to intial condition

\end{fulllineitems}

\index{surface() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.surface}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{surface}}}{\emph{iss}, \emph{it}, \emph{ekev}, \emph{srgh}, \emph{fmin}, \emph{pind}, \emph{alpha}, \emph{gamma}, \emph{angs}, \emph{refs}, \emph{gpitch}, \emph{dhub}, \emph{order}}{}
Set surface quality parameters
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{is}} \textendash{} surface quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{it}} \textendash{} surface type
1 refl. (Fresnel), 2 refl. (look-up), 3 refract, 4 diffract

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{elev}} \textendash{} photon energy keV

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{srgh}} \textendash{} Specific roughness (A**2 mm)
if -ve then rms figure gradient error radians

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fmin}} \textendash{} Minimum surface spatial frequency

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pind}} \textendash{} Surface roughness power spectrum index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{alpha}} \textendash{} real part of diel. constant or refractive index ratio N1/N2

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} \textendash{} imaginary part of dielectric constant

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{angs}} \textendash{} incidence angles (degrees increasing) (QTYPE 2 and 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refs}} \textendash{} reflectivity values (QTYPE 2 and 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gpitch}} \textendash{} d-spacing for grating mm (QTYPE 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dhub}} \textendash{} distance from ruling hub to surface reference point (QTYPE 4)
if \textless{}1.0 mm then d-spacing gradient across ruling (QTYPE 4)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{order}} \textendash{} diffraction order (QTYPE 4)

\end{itemize}

\end{description}\end{quote}

The X-ray optical constants \sphinxstylestrong{alpha} and \sphinxstylestrong{gamma} can be calculated for
a material of specified composition using the function xscat.xopt().
It \sphinxstylestrong{it=1} the X-ray reflectivity is calculated using the same
code as in the function xscat.

\end{fulllineitems}

\index{trace() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.trace}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{trace}}}{\emph{ideb}, \emph{riris}, \emph{iopt}}{}
Perform ray tracing
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ideb}} \textendash{} debugging level (0 none)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{riris}} \textendash{} radius about centre of detector for analysis
if 0.0 then no analysis of detected distribution

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iopt}} \textendash{} controls form of output

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{\sphinxstylestrong{iopt}:}] \leavevmode
\begin{DUlineblock}{0em}
\item[] -2 save traced.dat and detected.dat files
\item[] -1 save detected.dat
\item[] 0 don’t save files or adjust focus
\item[] 1 adjust focus and save detected.dat
\item[] 2 adjust focus and save detected.dat and traced
\item[] Only rays with \sphinxstylestrong{iopt} reflections are used in adjustment
\end{DUlineblock}

\end{description}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode

\begin{DUlineblock}{0em}
\item[] list of the following
\item[]
\begin{DUlineblock}{\DUlineblockindent}
\item[] \sphinxstylestrong{area}    detected area within RIRIS
\item[] \sphinxstylestrong{dshft}   axial shift to optimum focus (0.0 if IOPT\textless{}=0)
\item[] \sphinxstylestrong{ybar}    y centroid of detected distribution
\item[] \sphinxstylestrong{zbar}    z centroid of detected distribution
\item[] \sphinxstylestrong{rms}     rms radius of detected distribution
\end{DUlineblock}
\end{DUlineblock}


\end{description}\end{quote}

\end{fulllineitems}

\index{w1nest() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.w1nest}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{w1nest}}}{\emph{xj}, \emph{rj}, \emph{ra}, \emph{pl}, \emph{ph}, \emph{hl}, \emph{hh}, \emph{tin}, \emph{tj}, \emph{tout}, \emph{ax}, \emph{ar}, \emph{ff}, \emph{defi}, \emph{iq}, \emph{ib}}{}
Set up a Wolter Type I nest
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{xj}} \textendash{} axial position of join plane

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rj}} \textendash{} array of radii of shells at join

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ra}} \textendash{} ratio of grazing angles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pl}} \textendash{} low axial position of parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ph}} \textendash{} high axial position of parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hl}} \textendash{} low axial position of hyperbola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hh}} \textendash{} high axial position of hyperbola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ti}} \textendash{} array of thicknesses of shells at input aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tj}} \textendash{} array of thicknesses of shells at join plane

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tout}} \textendash{} array of thicknesses of shells at the output aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} \textendash{} direction of axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} reference axis in aperture

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ff}} \textendash{} position of focus

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{defi}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} reflecting surface quality index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ib}} \textendash{} back of shells surface quality index

\end{itemize}

\end{description}\end{quote}

The innermost shell is a dummy and provides an inner stop for the nest
\begin{description}
\item[{Deformation:}] \leavevmode
A deformation sub-matrix is required for each shell (not
including the innermost shell)
Each matrix covers a grid of points along the axis in mm and azimuth
in radians. The axial range covers both the 1st and 2nd reflection
surfaces.
The values in the matrices are radial displacments mm at the grid
points.

\end{description}

\end{fulllineitems}

\index{wolter2() (in module xsrt)}

\begin{fulllineitems}
\phantomsection\label{\detokenize{xsrt_functions:xsrt.wolter2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{xsrt.}}\sphinxbfcode{\sphinxupquote{wolter2}}}{\emph{rp}, \emph{gp}, \emph{rh}, \emph{gh}, \emph{rm}, \emph{fovr}, \emph{ax}, \emph{ar}, \emph{ff}, \emph{idf}, \emph{iq}}{}
Set up Wolter Type II surfaces
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rp}} \textendash{} maximum radius of parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gp}} \textendash{} grazing angle (degrees) at maximum radius on parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rh}} \textendash{} maximum radius of hyperbola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{gh}} \textendash{} grazing angle (degrees) at maximum radius on hyperbola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{rm}} \textendash{} minimum radius of parabola

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fovr}} \textendash{} radius of field of view degrees

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ax}} \textendash{} direction of axis of telescope

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ar}} \textendash{} reference direction perpendicular to axis

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ff}} \textendash{} position of focus of telescope

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{id}} \textendash{} deformation index

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{iq}} \textendash{} surface quality index

\end{itemize}

\end{description}\end{quote}
\begin{description}
\item[{Deformation:}] \leavevmode
A single deformation matrix specifies radial displacement errors mm
over a grid of points in  axial mm and azimuthal radians.
The grid covers the axial positions along both the 1st and 2nd
reflection surfaces.

\end{description}

\end{fulllineitems}



\chapter{Adding New Functions}
\label{\detokenize{qsoft_modifying:adding-new-functions}}\label{\detokenize{qsoft_modifying::doc}}
The top-level subroutines are written in Fortran 77.

Subroutines names are prefixed with:
\begin{itemize}
\item {} 
QRA\_ astronomy/astrophysics

\item {} 
QRX\_ X-ray astronomy/physics

\item {} 
QRI\_ image processing

\item {} 
QR\_FITS for the FITS file interface

\item {} 
QRT\_ sequential rays tracing interface

\item {} 
QR\_ general utilities

\end{itemize}

Internal Fortran routines also have prefixes:
\begin{itemize}
\item {} 
SRT\_ internal sequential ray tracing

\item {} 
AX\_ coordinate transformations

\item {} 
XX\_ X-ray physics

\item {} 
SYS\_ system utilities

\end{itemize}

Two general Fortran routines are also suppied, SCAN and LEN\_TRIM.

A few internal routines are written in C or C++. These are best left alone!

All the source code is held in directory:

\$QSOFT/src/


\section{Module Source Code}
\label{\detokenize{qsoft_source_code:module-source-code}}\label{\detokenize{qsoft_source_code::doc}}
The modules are independent and have no extenal dependencies.
If a routine is required
by more than one module then a copy of the source code
is included in each of the relevant source directories.

The source directories are:
\begin{itemize}
\item {} 
\$QSOFT/src/qfits

\item {} 
\$QSOFT/src/astro

\item {} 
\$QSOFT/src/images

\item {} 
\$QSOFT/src/xscat

\item {} 
\$QSOFT/src/xsrt

\end{itemize}

Each directory contains the Fortran interface routines, prefixed by QR, that
are called by Python, R or IDL and any internal Fortran subroutines required.

The source code for common blocks is held in files with uppercase
names without a Fortran extension *.f, e.g. SRT\_COM, SPX\_COM.
These are dragged into the subroutine source using the Fortran INCLUDE
statement.

In addition the directories contain the module definition scripts, e.g.
images.py, images.R. The IDL function interface is provided by
individual *.pro files for each command/function and these are held in
a subdirectory qIDL/ e.g. qIDL/qri\_getpos.pro, qIDL/qri\_beam.pro.

Each module directory contains a Makefile used to compile all the routines
and create shareable libraries for Python, R and IDL. Note that IDL
uses the library image created by R so R is required to produce the IDL
shareable. Once compiled you can install the library and definition
scripts using

\$ make install

This copies the shareable libraries and definition scripts to the
directories \$QSOFT/python\_modules, \$QSOFT/R\_libraries and
\$QSOFT/qIDL.


\section{The Ray Tracing Routines}
\label{\detokenize{xsrt_ray_tracing:the-ray-tracing-routines}}\label{\detokenize{xsrt_ray_tracing::doc}}
The driving routine, which is called by the interface routine
QRT\_TRACE is SRT\_TRACE. Within this routine there are two loops.
The outer loop is definite and works through the NRAYS which are
to be generated by the source.
The inner loop is indefinite and traces each ray through the surface elements.
The next surface in the sequence is determined by the outcome of encounters
with elements and multiple reflections between surfaces are allowed.
This inner loop is terminated when the ray is absorbed, detected or
finally misses the last element in the sequence.

Each surface element type is specified by an index as listed in this table:


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}{|l|l|l|l|l|l|l|l|}
\hline
\sphinxstyletheadfamily 
\#
&\sphinxstyletheadfamily 
surface
&\sphinxstyletheadfamily 
form
&\sphinxstyletheadfamily 
deform
&\sphinxstyletheadfamily 
limits
&\sphinxstyletheadfamily 
single/nest
&\sphinxstyletheadfamily 
code
&\sphinxstyletheadfamily 
ikon
\\
\hline
\endfirsthead

\multicolumn{8}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} -- continued from previous page}}}\\
\hline
\sphinxstyletheadfamily 
\#
&\sphinxstyletheadfamily 
surface
&\sphinxstyletheadfamily 
form
&\sphinxstyletheadfamily 
deform
&\sphinxstyletheadfamily 
limits
&\sphinxstyletheadfamily 
single/nest
&\sphinxstyletheadfamily 
code
&\sphinxstyletheadfamily 
ikon
\\
\hline
\endhead

\hline
\multicolumn{8}{r}{\makebox[0pt][r]{\sphinxtablecontinued{Continued on next page}}}\\
\endfoot

\endlastfoot

1
&
plane
&
open
&
normal
&
cartesian
&
single
&
plna
&
1
\\
\hline
2
&
plane
&
open
&
normal
&
radial
&
single
&
plna
&
2
\\
\hline
3
&
plane
&
open
&
radial
&
radial
&
single
&
plna
&
3
\\
\hline
4
&
plane
&
open
&
radial
&
radial
&
nested
&
plna
&
-n
\\
\hline
5
&
plane
&
closed
&
normal
&
cartesian
&
single
&
plne
&
1
\\
\hline
6
&
plane
&
closed
&
normal
&
radial
&
single
&
plne
&
2
\\
\hline
7
&
plane
&
closed
&
radial
&
radial
&
single
&
plne
&
3
\\
\hline
8
&
plane
&
closed
&
radial
&
radial
&
nested
&
plne
&
-n
\\
\hline
9
&
conic
&
grazing
&
radial
&
axial
&
single
&
cnic
&
1
\\
\hline
10
&
conic
&
normal
&
axial
&
radial
&
single
&
cnin
&
1
\\
\hline
11
&
conic
&
normal
&
axial
&
cartesian
&
single
&
cnin
&
2
\\
\hline
12
&
sphere
&
grazing
&
radial
&
cartesian
&
single
&
sphr
&
1
\\
\hline
13
&
sphere
&
grazing
&
radial
&
radial
&
single
&
sphr
&
2
\\
\hline
14
&
sphere
&
normal
&
radial
&
cartesian
&
single
&
sphr
&
3
\\
\hline
15
&
sphere
&
normal
&
radial
&
radial
&
single
&
sphr
&
4
\\
\hline
16
&
conic
&
normal
&
azimuthal
&
cartesian
&
single
&
cnin
&
3
\\
\hline
17
&
plane
&
open
&
normal
&
azimuthal
&
single
&
plna
&
4
\\
\hline
18
&
plane
&
open
&
normal
&
cartesian grid
&
single
&
plna
&
6
\\
\hline
19
&
conic
&
grazing
&
radial
&
axial+azimuthal
&
single
&
cnic
&
2
\\
\hline
20
&
plane
&
closed
&
normal
&
cartesian slat
&
single
&
plna
&
7
\\
\hline
21
&
sphere
&
pore
&
normal
&
pore
&
multiple
&
sphr+pore
&
5
\\
\hline
22
&
plane
&
open
&
normal
&
sector
&
single
&
plna
&
8
\\
\hline
23
&
conic
&
moa
&
radial
&
axial+azimuthal
&
multiple
&
cnic
&
3
\\
\hline
24
&
plane
&
Sipores
&
normal
&
pore
&
multiple
&
plna
&
9
\\
\hline
25
&
plane
&
KBstack
&
normal
&
slots
&
multiple
&
plna
&
9
\\
\hline
26
&
conic
&
normal
&
normal
&
axial+azimuthal
&
single
&
cnic
&
3
\\
\hline
27
&
plane
&
open
&
normal
&
parallelogram
&
single
&
plna
&
10
\\
\hline
28
&
sphere
&
MPOarr
&
normal
&
pore
&
multiple
&
sphr+arr
&
5
\\
\hline
29
&
plane
&
MPOtest
&
normal
&
pore
&
single
&
plna
&
11
\\
\hline
30
&
plane
&
SPOarr
&
normal
&
pore
&
multiple
&
plna
&
9
\\
\hline
31
&
sphere
&
Schmidt
&
normal
&
slot
&
multiple
&
sle
&
5
\\
\hline
32
&
plane
&
Schmidt
&
normal
&
slot
&
multiple
&
plns
&
1
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

Each of these surface types has a subroutine SRT\_SUnn associated with
it where nn is the type index. These routines call 1 of 13 routines which
find the intersection of rays with a plane, sphere, conic, square pores,
MOA slots, Si pores, Si pore array, K-B stack slots or Schmidt lobster stacks.
The pore and slot routines set up the parameters for 4 plane surfaces
which are then serviced by the SRT\_PLNE routine or SRT\_PLNS.
The Si pore routine
sets up the parameters for 8 plane surfaces to define the 1st and
2nd section of the Si pore.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline

SRT\_PLNA
&
aperture on plane surface
\\
\hline
SRT\_PLNE
&
plane surface
\\
\hline
SRT\_CNIC
&
conic at grazing incidence
\\
\hline
SRT\_CNIN
&
conic at normal incidence
\\
\hline
SRT\_SPHR
&
spherical surface
\\
\hline
SRT\_PORE
&
square pore
\\
\hline
SRT\_MOA
&
moa slots
\\
\hline
SRT\_SIPORE
&
Si pores
\\
\hline
SRT\_KBS
&
Kirpatrick-Baez stack
\\
\hline
SRT\_PLNS
&
Schmidt version of PLNE
\\
\hline
SRT\_SLE
&
Schmidt lobster stack
\\
\hline
SRT\_SPOARR
&
Si pores module array
\\
\hline
SRT\_SQMPOARR
&
Square pore MPO array
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

The combination of form, deformation, limits and single/nested used in each
of these routines is set by the integer argument IKON (see table above).
Full details about
these configurations and the parameters which they use are given in the
comments at the start of the code for each routine.

All the surface element parameters etc. are held in a common area. Individual
surface elements pick up their parameters using an index into this area.
The parameters are set by the following routines:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
routine
&\sphinxstyletheadfamily 
parameters
&\sphinxstyletheadfamily 
called by
\\
\hline
SRT\_SETF
&
surface
&
QRT\_MIRROR, QRT\_BAFFLE etc.
\\
\hline
SRT\_SETT
&
surface quality
&
QRT\_SURFACE, QRT\_LENS, QRT\_PRISM
\\
\hline
SRT\_SETD
&
deformation
&
QRT\_DEFS
\\
\hline
SRT\_SETS
&
source
&
QRT\_SOURCE
\\
\hline
SRT\_SETCONCOM
&
SPO constellation
&
QRT\_SIPORE
\\
\hline
SRT\_SETKBSCOM
&
KBS constellation
&
QRT\_KBS
\\
\hline
SRT\_SETMPOARR
&
MPO array
&
QRT\_SQMPOARR
\\
\hline
SRT\_SETSLECOM
&
Schmidt lobster eye
&
QRT\_SLE
\\
\hline
SRT\_SETSPOCOM
&
Si Pore Optics
&
QRT\_SPOARR
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

These routines put the parameters
into common blocks. The order of the parameters is important and must
match the order expected by the target routine. The sequence of
parameters expected is specified in the comment lines at the top
of the surface element routines.


\section{New Surface Elements}
\label{\detokenize{xsrt_new_surfaces:new-surface-elements}}\label{\detokenize{xsrt_new_surfaces::doc}}
In order to introduce a  new type of ray tracing optical element you
should check the list of available surface types. For example a
spherical mirror at normal incidence using radial limits
would be implemented using TYPE=15. If the required surface type
exists then you only need to
write a QRT\_new routine which provides the QSOFT xsrt interface.
This is easily done
by copying and editing an existing routine, e.g. QRT\_SPIDER.

If you want to add a new element which contains multiple surface elements then
you should start with a routine like QRT\_SPOARR. In this case
you will also require
new surface element routines e.g. SRT\_SU30 and SRT\_SPOARR are
required by QRT\_SPOARR.

The steps required to compose, compile and link are as follows:
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\item {} 
Go to the source directory \$QSOFT/src/xsrt

\item {} 
Write the new QRT\_new routine as file qrt\_new.f.
\begin{quote}

Note down the parameters names required by this routine.
\end{quote}

\item {} 
Edit the Makefile to include qrt\_new.f in the source file list.

\item {} 
Use make to compile the new routine and link the shareble library
\begin{quote}

\$ make
\end{quote}

\item {} 
Edit the xsrt.R and xsrt.py script files to include the new function.
\begin{quote}

If you are going to use IDL move into the qIDL directory and create
a qrt\_new.pro file to define the function for IDL.

You can use the definitions already present in these files
to see how the interface works.
\end{quote}

\end{enumerate}

If the new optical element is not supported by any existing surface
type then a new type must be invented. The programmer must write
a new SRT\_SUnn routine and modify and existing
or produce a new SRT\_type routine.
A call to the new SRT\_SUnn must also be included in the inner loop
of the srt\_trc.f file. The new SRT\_SUnn and SRT\_type routines
must be edited into the makefile. Otherwise the process is
the same as indicated above.

It is important that the parameters gathered by QRT\_new are packed into
common in the right order so that the relevant surface routine
(SRT\_PLNE etc.) access the parameters correctly. The programmer
must check this by reading the comment lines at the start of
the relevant surface routine.

The routine SRT\_SETF is used to push the parameters into common.
This has the following interface:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{*}\PYG{o}{+}\PYG{n}{SRT\PYGZus{}SETF}      \PYG{n}{Set} \PYG{n}{surface} \PYG{n}{form} \PYG{n+nb}{and }\PYG{n}{limits} \PYG{n}{parameters}
    \PYG{k}{SUBROUTINE }\PYG{n}{SRT\PYGZus{}SETF}\PYG{p}{(}\PYG{n}{NS}\PYG{p}{,}\PYG{n}{IT}\PYG{p}{,}\PYG{n}{NP}\PYG{p}{,}\PYG{n}{P}\PYG{p}{,}\PYG{n}{IDEF}\PYG{p}{,}\PYG{n}{IQ}\PYG{p}{,}\PYG{n}{IH}\PYG{p}{,}\PYG{n}{IM}\PYG{p}{,}\PYG{n}{ISTAT}\PYG{p}{)}
    \PYG{k}{IMPLICIT }\PYG{k}{NONE}
\PYG{k}{    }\PYG{k+kt}{INTEGER }\PYG{n}{NS}\PYG{p}{,}\PYG{n}{IT}\PYG{p}{,}\PYG{n}{NP}\PYG{p}{,}\PYG{n}{IDEF}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{,}\PYG{n}{IQ}\PYG{p}{,}\PYG{n}{IH}\PYG{p}{,}\PYG{n}{IM}\PYG{p}{,}\PYG{n}{ISTAT}
    \PYG{k+kt}{DOUBLE PRECISION }\PYG{n}{P}\PYG{p}{(}\PYG{n}{NP}\PYG{p}{)}
\PYG{o}{*}\PYG{n}{NS}     \PYG{n}{input}   \PYG{n}{surface} \PYG{n}{number} \PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{for} \PYG{n}{new} \PYG{k}{entry}\PYG{p}{)}
\PYG{o}{*}\PYG{n}{IT}     \PYG{n}{input}   \PYG{n}{surface} \PYG{k}{type}
\PYG{o}{*}\PYG{n}{NP}     \PYG{n}{input}   \PYG{n}{number} \PYG{n}{of} \PYG{n}{parameters}
\PYG{o}{*}\PYG{n}{P}      \PYG{n}{input}   \PYG{k}{array }\PYG{n}{of} \PYG{n}{parameters}
\PYG{o}{*}\PYG{n}{IDEF}   \PYG{n}{input}   \PYG{n}{deformation}
\PYG{o}{*}\PYG{n}{IQ}     \PYG{n}{input}   \PYG{n}{surface} \PYG{n}{quality}
\PYG{o}{*}\PYG{n}{IH}     \PYG{n}{input}   \PYG{n}{hit} \PYG{n+nb}{index} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{ve} \PYG{n}{for} \PYG{n}{next} \PYG{n}{in} \PYG{k}{sequence}\PYG{p}{)}
\PYG{o}{*}\PYG{n}{IM}     \PYG{n}{input}   \PYG{n}{miss} \PYG{n+nb}{index} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{ve} \PYG{n}{for} \PYG{n}{next} \PYG{n}{in} \PYG{k}{sequence}\PYG{p}{)}
\PYG{o}{*}\PYG{n}{ISTAT}  \PYG{n}{in}\PYG{o}{/}\PYG{n}{out}  \PYG{n}{returned} \PYG{n}{status}
\PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{n}{Author} \PYG{n}{Dick} \PYG{n}{Willingale} \PYG{l+m+mi}{1996}\PYG{o}{\PYGZhy{}}\PYG{n}{Dec}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{6}
\end{sphinxVerbatim}

NS=0 if you want the surface to be allocated the next free
index in the sequence. IT is the surface index and determines
which SRT\_SUnn routine is going to be called in the ray tracing loop.
Note that the parameters are held in a double precision array.
IDEF and IQ are deformation and surface quality indices that
have already be set by DEFORM and SURFACE commands. If IDEF=0
no deformation will be used. If IQ=0 then the surface will act as a stop.
IH and IM are used
to steer the sequence in the ray tracing. They specify which
surface in the sequence should be next depending on whether or
not the present surface is hit or missed. In most cases IH=-1 and
IM=-1. Examples of cases where a more complicated behaviour is
required are SRT\_PORE and QRT\_SQPORE.
\begin{enumerate}
\def\theenumi{\arabic{enumi}}
\def\labelenumi{\theenumi .}
\makeatletter\def\p@enumii{\p@enumi \theenumi .}\makeatother
\setcounter{enumi}{5}
\item {} 
Use make to install the new libraries and scripts.
\begin{quote}

\$ make install
\end{quote}

\end{enumerate}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{a}
\item\relax\sphinxstyleindexentry{astro}\sphinxstyleindexpageref{astro_functions:\detokenize{module-astro}}
\indexspace
\bigletter{i}
\item\relax\sphinxstyleindexentry{images}\sphinxstyleindexpageref{images_functions:\detokenize{module-images}}
\indexspace
\bigletter{q}
\item\relax\sphinxstyleindexentry{qfits}\sphinxstyleindexpageref{qfits_functions:\detokenize{module-qfits}}
\indexspace
\bigletter{x}
\item\relax\sphinxstyleindexentry{xscat}\sphinxstyleindexpageref{xscat_functions:\detokenize{module-xscat}}
\item\relax\sphinxstyleindexentry{xsrt}\sphinxstyleindexpageref{xsrt_functions:\detokenize{module-xsrt}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}